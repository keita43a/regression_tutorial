[["index.html", "武蔵大生のためのRによる実証分析入門 Chapter 1 この資料について", " 武蔵大生のためのRによる実証分析入門 Keita Abe 2024-06-13 Chapter 1 この資料について この武蔵大学経済学部でのRを用いた実証分析入門の資料です。 武蔵大学経済学部の学生の状況を背景に、最低限でなんとか実証分析を行うところまで学ぶことを意図した資料になっています。 Rの入門については、より詳しい以下の資料やウェブサイトが存在しますので、詳しい説明が知りたい学生はそちらを参照することをおすすめします。 わたしたちのR R言語入門 実証分析のベースとなる計量経済学についてはこれらの書籍がおすすめです。 計量経済学の第一歩 実証分析のススメ また、Rによる実証分析についても多くの書籍が出版されています。そちらも参照してください。 Rによるデータ分析入門 Rによる実証分析 第2版 Rによる計量政治学 "],["whatsr.html", "Chapter 2 Rとはなにか？ 2.1 R? 2.2 Excelじゃだめなのか 2.3 Rのよいところ 2.4 例えばRでできること：図表 2.5 例えばRでできること：ウェブアプリ 2.6 例えばRでできること：ウェブスクレイピング 2.7 地図の分析・活用 2.8 Rの欠点 2.9 CUIとGUI 2.10 プログラミング", " Chapter 2 Rとはなにか？ 2.1 R?  R は統計、データ分析、作図のためのインタープリタープログラミング言語 統計やデータ分析を行うアプリ 他にはSPSS, Stata Pythonもよく使われる 2.2 Excelじゃだめなのか Excel は表計算ソフトで多くの機能を有している Excelでできること 計算する 図を描く 基本的な統計分析 ではExcelではだめなのか？ Excelでも最低限のことはできますが、分析が複雑になっていくと手数も増えていきます。 特に、Excelだと同じことをもう一度やる（データを変えて同じ分析をする、など）がやりにくく、ミスも起きやすくなります。 本当に初歩の初歩ならエクセルで十分ですが、ある程度の実証分析をやろうと思うとRなどを学ぶほうが回り道のようで結局早い 2.3 Rのよいところ 無料 多くにプラットフォーム（MacOS, Windows, Linux)で使用可能 たくさんの資料がネット上に存在する 分析結果をプレゼンテーションするツールが充実している Rstudio: 統合開発環境(IDE) 豊富なパッケージ 多くのエンジニアや研究者が公開 2.4 例えばRでできること：図表 Rでは、柔軟に図表を描くことができます。例えば以下の図は、武蔵大学のウェブサイトに公開されている学生数のデータを描画したものです。少しやり方を学べば、以下のような図を簡単に作成することができます。 2.5 例えばRでできること：ウェブアプリ Rではインタラクティブなウェブアプリも作ることができます。以下の例は、数値をユーザーが変えることで結果のグラフが変化して表示される簡単なウェブアプリです。 例 2.6 例えばRでできること：ウェブスクレイピング 2.7 地図の分析・活用 2.8 Rの欠点 Rは進化が速い 処理が比較的遅い 一般的なデータ分析をするのには問題がない Excelよりは速い ビッグデータや複雑な統計モデルを走らせると、遅かったりメモリ消費が激しい CUIなので、最初の学習が難しい 2.9 CUIとGUI CUI: Character User Interface 命令を文字で行う（キーボードを使う）操作環境 GUI: Graphic User Interface マウスでクリックしながら使う操作環境 2.9.1 GUIの方が楽？ GUIの方が楽では？ マウスで操作ができる方がよさそう？ CUIは記録ができる 何度も同じ操作ができる 人が書いた一連の操作（コード）をコピー・参考にできる 柔軟性が高い Rを使う統合環境であるRStudioは、CUIながらGUI的に作業を行える部分もある環境を提供する。 2.10 プログラミング やることはプログラミング PythonもJavaも、まずはプログラミングを理解すると学べるようになる Rは比較的わかりやすい言語 ゼミでは基本的なデータ描画と統計分析をできるようになることが目標 "],["howtostart.html", "Chapter 3 Rのはじめかた 3.1 Rをどうやって使う？ 3.2 Rstudioを使う3つの方法 3.3 Rのインストール 3.4 Rstudioのインストール 3.5 Rstudioのインターフェース 3.6 コンピュータのディレクトリ構造 3.7 演習：作業フォルダを作ろう 3.8 作業スペース 3.9 プロジェクトの作成 3.10 演習: Rプロジェクトを作成してみよう 3.11 とりあえず触ってみる 3.12 スクリプトの作成 3.13 実行してみる 3.14 スクリプトを書く際の注意点 3.15 エラーを恐れるな！ 3.16 Rstudioの補完機能 3.17 Rstudioのオプション", " Chapter 3 Rのはじめかた 3.1 Rをどうやって使う？ Rを使うにはいくつか方法がある。 統合開発環境 IDE: Integrated Development Environment ソフトウェア開発や、データ分析のプロセスをワンストップで行える環境 一部GUIを導入したり、CUIによる操作をアシストする 特に強い好みがない限り、Rstudioをおすすめ R 単体でも使えるが、RstudioでRを使うほうが直感的で使いやすい。 3.2 Rstudioを使う3つの方法 PCにインストール 自分のPCにインストール ネット環境がなくても使える 自分のPCにファイルにアクセスして使える 学校のパソコンを使う 学校のパソコンにはRとRStudioがインストールされている 学校に自分のPCを持ってこなくてもよいが家で勉強できない Rプロジェクトを用いた際にネットワークドライブに置いた場合、ワーキングディレクトリの挙動がおかしいので、パソコンのpathなどに詳しくない人は混乱するかもしれない。 posit.Cloudの無料プランを使う クラウド上でRstudioを使う 利点：コンピューター上の設定が不要 欠点：データファイルなどを毎回アップロードする必要がある。ファイル数などは限られる。 できれば1の方法でやってみよう。 3.3 Rのインストール 学校のパソコンにはすでにインストールされている 自分のパソコンに導入する人はこのスライドかここにある「RとRStudioのインストール方法の解説」を参照 3.3.1 Windownsへのインストール ブラウザからCLANへアクセスする もし繋がらなければこちらから試してみる 「Download R for Windows」-&gt; 「base」-&gt; 「Download R-4.3.3 for Windows」 R-4.3.3-win.exeがダウンロードされる この資料が更新されていなければ4.3.3.より新しいバージョンになっているかもしれない。 Figure 3.1: Rのダウンロード。Windowsの場合 Figure 3.2: Rのダウンロード。Windowsの場合 Figure 3.3: Rのダウンロード。Windowsの場合 R-4.3.3-win.exeをクリックしてインストールする 基本的に「はい」や「次へ」で良い 「起動時オプション」は「いいえ」（デフォルト状態） 「このアプリがデバイスに変更を加えることを許可しますか」と出たら「はい」 完了したらデスクトップやアプリ一覧にR.4.3.3があるかどうかチェック 3.3.2 Mac OSへのインストール Mac OSへのインストールは少し大変である。一つずつ確認していこう。 3.3.2.1 チップの種類を確認 まず自分のMacがIntelチップかApple Siliconかを確認する 左上のリンゴマーク→「このMacについて」 表示された情報の「チップ」が「Apple M1」やM2,M3であればApple silicon, IntelであればIntel 3.3.2.2 Command Line Toolsのインストール Macのアプリ一覧から、「ターミナル」を開く。 Figure 3.4: ターミナル ターミナルを開くと以下のような画面が出てくる。以下の画面は私のPCなのでkeitaになっているが、実際にはそれぞれのユーザーネームになっている。 Figure 3.5: ターミナルの画面 ターミナルで自分のユーザー名の隣の$マークの後ろに以下のように入力する。 $ xcode-select --install もし$マークがなくて、%になっていたら、%のあとにxcodeから始めて入力する。 % xcode-select --install あとは指示に従う。 もしerror: command line tools are already installed, use \"Software Update\" to install updatesというメッセージが出たらCommand Line Toolsはすでにインストールされている。 もしこれで、うまくいかない場合は次のXcodeをインストールすることでCommand Line Toolsをインストールする。 3.3.2.3 Xcodeのインストール Xcodeは上のCommand Line Toolsがインストールできればとりあえず不要（のはず）である。もしできばければ、インストールしよう。ここではApple IDが必要となる。Xcodeは非常に大きいので、WiFiなどのインターネット接続が安定しているところで、時間のあるときにやりましょう。 MacのApp Storeから、Xcodeをインストールする。 App Storeを開いて、Xcodeを検索する。下のようなハンマーのアイコンのアプリである。これをインストールする。 Figure 3.6: Xcode App Storeの使い方がわからない人は、App Storeユーザーガイドを参照してください。 3.3.2.4 XQuartzのインストール XQuartzのウェブサイトにアクセスして、Quartz-x.x.x.pkgというファイルをダウンロードする。xにはバージョン名が入るので、2024年4月時点では2.8.5だが、それより新しいバージョンになっているかもしれない。 Figure 3.7: XQuartzのダウンロード画面 ダウンロードされたpkgファイルを開いて、インストールする。 3.3.2.5 Rのダウンロード ブラウザからCLANへアクセスする もし繋がらなければこちらから試してみる 「Download R for Mac OS」をクリック Apple Siliconの場合は、R-4.3.3-arm64.pkgをダウンロード Intelの場合は、R-4.3.3-x86_64.pkgをダウンロード Figure 3.8: Rのダウンロード。MacOSの場合 Figure 3.9: Rのダウンロード。MacOSの場合 ダウンロードしたpkgファイルをクリックしてインストールする 基本的には「次へ」「同意する」を押す インストール先：Macintosh HD 標準インストール 完了したら、アプリ一覧にRがあるかどうかチェック Figure 3.10: MacのLaunchpad上に表示されているR 3.4 Rstudioのインストール Posit社のウェブサイトへアクセス “2. Install RStudio”の青いボタンをクリック Figure 3.11: RStudioのダウンロード。図はMacOSの場合 ダウンロードされたファイルをクリックしてインストールする。基本的に「次へ」でよい。 完了したら、アプリ一覧に丸いロゴでRと書いてあるRStudioがあるかチェック。Windowsの場合はデスクトップにショートカットが生成されない可能性があるので、アプリ一覧でチェックしよう。 3.5 Rstudioのインターフェース RStudioは４つのペーンに分割されている。もし３つしかない、という人は左上の白い四角に緑の＋マークが付いているところを押して”R Script”を選ぼう。すると左上のペーンが現れて新たなスクリプトファイルが生成される。 Figure 3.12: Rstudio見た目 3.6 コンピュータのディレクトリ構造 コンピュータでファイルなどを扱う上で、pathという概念を理解しておく必要がある。パソコンを使っているとフォルダをよく使う。自分が作ったファイルをフォルダに保存するなどである。これはCUIではディレクトリと呼ばれる。 コンピュータ上においては、ファイルの場所はpathで表現される。これはコンピュータ上の住所のようなものである。 j:というドライブの下のabezemiというフォルダの下にあるr_renshuというフォルダにあるkadai1.Rというファイルがあるとする。そのファイルのpathはj:/abezemi/r_renshu/kadai1.Rとなる。 コンピュータ上では、このように文字でファイルの場所と名前を指定することがよくある。 Figure 3.13: ディレクトリ構造 3.7 演習：作業フォルダを作ろう (Windows) ドライブ上で右クリック→新規作成→フォルダ (Mac) Finderの右上の◯に…のマークをクリック→新規フォルダ 3.7.1 自分のパソコン 例えば「ドキュメント」(Windows)や「書類」(Mac)の下にabezemiフォルダを作成 3.7.2 学校のパソコン 自分の学生番号のドライブ(例 s1234567)の下に abezemi フォルダを作成 3.7.3 Posit.cloud Posit.clouの場合は、まだここでは何もする必要はない。 3.8 作業スペース コンピューター上では、どこかのディレクトリ（フォルダ）がRの作業場所になっている。 今の作業場所はgetwd()で表示できる。 getwd() これを変更するにはsetwd(path)で変更できる。 # Windowsの場合 # keitaを自分のユーザー名に変える setwd(&quot;C:/keita/Documents/abezemi&quot;) # Mac OSの場合 # keitaを自分のユーザー名に変える setwd(&quot;/Users/keita/Documents/abezemi&quot;) # 学校のPCの場合 setwd(&quot;j:/abezemi&quot;) ここではj:ドライブの下のabezemiフォルダに設定。 もう一度getwd()して変更されたか確認しよう。 3.9 プロジェクトの作成 作業場所を指定しても、ファイルの管理が面倒だったりする。 RStudioのRプロジェクトという機能を使うと、以下のメリットがある データやスクリプト（コード）へのアクセスが容易 Gitによるバージョン管理のベースにもなる 異なる環境でも同じ作業スペースが設定される 一つのプロジェクトについてひとまとまりのファイルとして管理できる 3.10 演習: Rプロジェクトを作成してみよう File -&gt; “New Project” -もしくは右上の “Project (none)” New Directoryでプロジェクトを作成 “New Project”を選択 プロジェクト名を入力: r_renshu プロジェクト名は英語で。 日本語は使えない（もしくはトラブルの元になる） スペースも使わない。アンダーバーやハイフンを代用できる。 2つ目の欄には、どのディレクトリの下にプロジェクトディレクトリを作るかを指定する。 今回はabezemiの下につくるので、Browseを開いて上で作ったabezemiフォルダを指定してOpenをクリック。 Figure 3.14: Rプロジェクトの作成 プロジェクトが作成されると、作成したディレクトリにはプロジェクト名.Rprojという名前のファイルが作成される 今回はabezemiの下にr_renshuフォルダが作成され、r_renshu.Rprojというファイルができる プロジェクトの設定などを保存 3.11 とりあえず触ってみる Rとの”対話”は、Rstudioの左下のペイン(コンソール)で行われる。 コンソールに、1+1と打ってみる。 すると、2と表示される。 1 + 1 ## [1] 2 3.12 スクリプトの作成 そのままConsoleに入力していってもよいが、スクリプト(コード)に書くことで、記録を残しながらRに命令を与えることができる。 3.12.1 演習：スクリプトを作成してみる Rスクリプトを作成する 上のメニューのFile -&gt; New File -&gt; R script もしくは左上の区画のから、「R Script」 “Untitled1”というRスクリプトが作成されるので名前をつけて保存する File -&gt; Save As… -&gt; r_renshu.Rという名前をつけて保存 もしくは右上のフロッピーを押してr_renshu.Rという名前をつけて保存 3.13 実行してみる R scriptに以下のように書く print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; カーソルが同じ行にあることを確認して、をクリック もしくは、[Ctrl]を押しながら[Enter] (MacならCommand+Enter) “Hello World!”と表示されれば成功。 3.13.1 コードを実行する際のポイント 実行したい範囲を選択してRunを押すと実行されるが、[Ctrl]を押しながら[Enter] (Macなら[Command]+[Enter])でも実行される。 また、範囲を選択しなくてもカーソルがあるところでRunか[Ctrl]+[Enter]を押すと、その行だけ（もしくはコードとして一つの命令になっている行数だけ）実行される。いちいち範囲選択しなくても良いので便利。 3.14 スクリプトを書く際の注意点 3.14.1 コメント R script上では#から始まる行は、コメントとして認識され、実行するとコンソールには表示されるが、何も起こらない。 メモなどを書く際に使う。 # これは初めてのRのコードです。 print(&quot;Hello World&quot;) ## [1] &quot;Hello World&quot; もしくは一度使ったが、今は実行したくないコードを一時的に無効にする。これはコメントアウトというプログラミングにおける基本的なテクニック。 # print(&quot;Good Evening&quot;) 3.14.2 スクリプトは読みやすく コメントや改行を活用して読みやすいコード（スクリプト）を書く。 Rのコードでは空行は意味をなさないのでいくらでも空けてよい。 良い例 # Rの練習１ # 2024年4月15日 # ライブラリ library(tidyverse) # コード本体 # はじめまして print(&quot;Hello World!&quot;) # 足し算 x &lt;- 1 + 1 # データを読み込む # このデータはXXでダウンロードした data &lt;- read_csv(&quot;data/data1.csv&quot;) 良くない例 library(tidyverse) print(&quot;Hello World!&quot;) x &lt;- 1 + 1 data &lt;- read_csv(&quot;data/data1.csv&quot;) 3.15 エラーを恐れるな！ 間違ったコマンドを入力すると赤字でエラーが出る。 怖がらなくてよい。間違ってると教えてくれてるだけ。 .(ドット)と,(コンマ)を間違えただけでもうまくいかないのがプログラミング。注意深く書こう。 # これは間違ったコード(tを忘れてる) prin(&quot;Hello World&quot;) ## Error in prin(&quot;Hello World&quot;): could not find function &quot;prin&quot; 3.15.1 よくあるエラー1 Error in read_csv(\"data/Countries.csv\") : could not find function \"read_csv\" XXXという関数が見つかりません、というエラー 考えられるケース library()で必要なパッケージを読み込めてない 関数のつづりが間違っている 3.15.2 よくあるエラー2 Error: 'data/Countris.csv' does not exist in current working directory XXX.csvというファイルが作業場所にありません。 考えられるケース - そもそもファイルがない（保存した場所を間違えた） - ファイルの指定場所が間違っている - つづりが間違っている 3.16 Rstudioの補完機能 オブジェクト内の要素や、ファイル名などを補完してくれる機能 3.17 Rstudioのオプション Rstudioを自分好みにカスタマイズすることが可能 [Tools]-&gt;[Global Options…] Rstudio全般 コーディング 外観 ターミナル キーボードショートカット 3.17.1 例：外観の変更 "],["letsuse.html", "Chapter 4 Rを使ってみる 4.1 計算機としてのR 4.2 プログラミング言語としてのR 4.3 データ型 4.4 ベクトル 4.5 リスト", " Chapter 4 Rを使ってみる 4.1 計算機としてのR 4.1.1 演習：R Scriptの作成 r_renshuプロジェクトを開く。 新たにr_trial.Rという名前のRスクリプトを作成しよう。 スクリプトの作り方を忘れた人はセクション3.12を参照。 以下の演算をそのスクリプトに書いて実行してみよう。 4.1.2 足し算・引き算 1 + 1 ## [1] 2 400 - 50 ## [1] 350 4.1.3 かけ算・割り算 掛け算はアスタリスク(*)を使う。 2 * 3 ## [1] 6 割り算はスラッシュ(/)を使う (2+7)/3 ## [1] 3 割り切れない場合はある程度まで桁が表示 10/3 ## [1] 3.333333 4.1.4 練習問題：以下の演算をRを使ってやってみよう \\(9179\\div67\\) \\((256\\times 43 + 54)\\div 8\\) \\(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12\\) 4.1.5 論理演算 論理演算は書いてあることが真か偽か？を評価する。 # 「10は5より大きい」という命題は正しい？ 10 &gt; 5 ## [1] TRUE # 「3は5より大きい」という命題は正しい？ 3 &gt; 5 ## [1] FALSE # 「等しい」は=が2つ。１つだと「代入」という意味になってしまう。 &quot;musashi&quot; == &quot;musashi&quot; ## [1] TRUE &quot;musashi&quot; == &quot;634&quot; ## [1] FALSE # musashiと634は等しくない、という命題 &quot;musashi&quot; != &quot;634&quot; ## [1] TRUE OR 演算 # 2つの論理演算のいずれかがTRUEならTRUE (5 == 5) | (3 == 3) ## [1] TRUE (5 == 5) | (&quot;musashi&quot; == &quot;634&quot;) ## [1] TRUE AND 演算 # 複数の論理演算の全てがTRUEならTRUE (5 == 5) &amp; (3 == 3) ## [1] TRUE (5 == 5) &amp; (&quot;musashi&quot; == &quot;634&quot;) ## [1] FALSE 4.2 プログラミング言語としてのR 4.2.1 変数へのオブジェクトの代入 x や yという「入れ物」に数字を代入する。 x &lt;- 8 # 代入は &lt;- y = 3 # 代入は = でもよい z &lt;- x + y z ## [1] 11 オブジェクトは「上書き」できることに注意。 以下の例では、xに3を代入した後x+1という演算をまた、xに代入している。 それによって、xは4となる。 x &lt;- 3 x &lt;- x + 1 x ## [1] 4 4.2.2 プログラミング：繰り返し 同じような作業を繰り返させる。 以下のケースでは、\\(i\\)というオブジェクトに1から10までを順番に入れて、それぞれのターンにおいて\\(i+1\\)という数字をprint()という関数でコンソールに表示させている。つまり、同じ作業を10回中身を変えてやりたいときに、print(1+1), print(2+1)...というように、何度も同じ文を書く必要がない。 for(i in 1:10){ print(i+1) } ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 4.2.3 練習問題：ループを用いた計算 1から50までを合計する繰り返し文を書いてみよう。 \\(1+2+3+\\cdots+50=\\) ヒント：goukeiというオブジェクトを用意して、ループの前に0を代入してみよう。 4.2.4 プログラミング：if文 もしある命題が真ならどうする、偽ならどうするというifの条件によって異なる処理を行うif文もプログラミングの基本だ。Rでも簡単に実装できる。 x &lt;- 5 # もしxが0より大きいなら、yに3+xを代入するという処理を実行する。 if(x &gt; 0){ y = 3 + x } print(y) ## [1] 8 x &lt;- -4 # もしxが0より大きいなら、wに3+xを代入するという処理を実行する。 if(x &gt; 0){ w = 3 + x } # 上の処理は実行されていないのでwは定義されず、&quot;not found&quot;というエラーが出る。 print(w) ## Error in eval(expr, envir, enclos): object &#39;w&#39; not found もし命題が偽だった場合の処理も指定できる。 x &lt;- -5 # もしxが0より大きければ3を足してvに代入、 # そうでなければ3を引いてvに代入。 if(x &gt; 0){ v = x + 3 }else{ v = x - 3 } print(v) ## [1] -8 4.3 データ型 Rのオブジェクトにはいくつかの「型」がある。そのオブジェクトに格納されている要素がどういう性質を持つか？が定義される。これを、データ型と呼ぶ。 たとえば、数字なのか文字列なのか？で扱いが異なる。 # 実数 x &lt;- 634 mode(x) ## [1] &quot;numeric&quot; # 文字列 y &lt;- &quot;musashi&quot; mode(y) ## [1] &quot;character&quot; 4.3.1 データ型：注意点 我々の目には同じ634であっても、データ型が文字列として定義されていると、コンピューターは計算ができない。ただ6.3.4.と書かれている文字であって、数字ではないという認識がなされるからである。 # 数字だが文字列 z &lt;- &quot;634&quot; mode(z) ## [1] &quot;character&quot; z + 6 ## Error in z + 6: non-numeric argument to binary operator 4.3.2 データ型の変換 # データ型のチェック mode(z) ## [1] &quot;character&quot; # 実数かどうか？ is.numeric(z) ## [1] FALSE # データ型を実数に変換して再度zに代入 z &lt;- as.numeric(z) # 再度チェック is.numeric(z) ## [1] TRUE 4.4 ベクトル 順序のある要素の集まりをベクトルと呼ぶ。 c()関数で作成することができる。 v1 &lt;- c(1,2,3,4,5) print(v1) ## [1] 1 2 3 4 5 ベクトルは、文字や論理値など取ることができる。 v2 &lt;- c(&quot;musashi&quot;,&quot;nerima&quot;,&quot;ekoda&quot;) print(v2) ## [1] &quot;musashi&quot; &quot;nerima&quot; &quot;ekoda&quot; v3 &lt;- c(FALSE,TRUE,TRUE,FALSE) print(v3) ## [1] FALSE TRUE TRUE FALSE 4.4.1 ベクトルの型 異なるデータ型を同じベクトルに混ぜることはできない。 混ぜると、一定のルールに基づいてある型が他の型より優先される # 数値と論理値を混ぜると、数値になる。(FALSE-&gt;0, TRUE-&gt;1) v4 &lt;- c(FALSE,1,TRUE) print(v4) ## [1] 0 1 1 # 数値と論理値と文字列を混ぜると、全部文字列になる v5 &lt;- c(FALSE,1,&quot;musashi&quot;) print(v5) ## [1] &quot;FALSE&quot; &quot;1&quot; &quot;musashi&quot; 4.4.2 ベクトル：連続した数値 連続した数値を入力したい場合はコロン:を使う v6 &lt;- c(1:10) print(v6) ## [1] 1 2 3 4 5 6 7 8 9 10 nずつ増える数列を作りたい場合は、seq()関数を使う # 例：2から50まで２ずつ増える数列 v7 &lt;- seq(2,50,by=2) 4.4.3 練習問題: 数列の作成 3から60まで3ずつ増える数列ベクトルを作りなさい 4.4.4 ベクトル：同じ数値が並ぶベクトル 同じ数値がたくさんあるベクトルを作りたい場合はrep()関数を使う # 5が100個ならぶベクトル v8 &lt;- rep(5,100) print(v8) ## [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 ## [79] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 本当に100個出てるか？ ベクトルの要素の数を数える関数はlength length(v8) ## [1] 100 4.4.5 練習問題：ベクトルの作成 seq()関数とrep()関数を使って、2,4,6,8,10が5回連続するベクトルをつくってみよう。 結果をv9_exというオブジェクトに格納して、コンソールに結果を表示しよう。 4.4.6 ベクトル要素の参照 ベクトルのn個目の要素を参照したいときは角カッコを使う[] # v7の3つ目の要素は6 v7[3] ## [1] 6 # v7の2,3,5つ目の要素 v7[c(2,3,5)] ## [1] 4 6 10 4.5 リスト 様々なベクトルやデータなどのオブジェクトをひとまとめにして扱うことができるのがリスト リストはlist()関数で作成する # aというオブジェクトに、文字列ベクトル、数値ベクトル、データが混ざって入っている。 # カンマ, の後に改行しているが、listのかっこが閉じるまではひとまとまりだと扱われる。 a &lt;- list( c(&quot;a&quot;, &quot;b&quot;, NA, &quot;d&quot;), num = c(3, 1.1, 5), data = head(mtcars, 1)) a ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; NA &quot;d&quot; ## ## $num ## [1] 3.0 1.1 5.0 ## ## $data ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 4.5.1 リストの参照 リストの参照も角カッコでできる # リストの参照 a[1] ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; NA &quot;d&quot; a[2] ## $num ## [1] 3.0 1.1 5.0 4.5.2 リストの参照 リストの中身のみを取り出したい場合は、二重括角カッコを使う[[]] a[[3]] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 "],["packages.html", "Chapter 5 パッケージとは 5.1 パッケージについて 5.2 パッケージのインストール 5.3 よく使うパッケージのインストール 5.4 パッケージの使い方1 5.5 パッケージの使い方2 5.6 パッケージの注意点", " Chapter 5 パッケージとは 5.1 パッケージについて Rはデフォルト(初期状態)でインストールされている関数がたくさんある。 ベクトルの長さを測るlength()や、散布図を描くplot()などは関数であり、もともとRをインストールした時点で入っている。 しかし、さらにRを拡張して機能を強化することができる。 それがパッケージのインストールである。 たとえばスマホにはもともと基本アプリが入っているが、さらにいろんなアプリをダウンロードしてインストールできることに似ている。 しかしパッケージは無料である。 5.2 パッケージのインストール パッケージのインストールをする方法は二つある。 install.packages()関数を使う方法 install.packages(&quot;ggplot2&quot;) Rstudioの右下の区画の[Packages]タブから、[Install]ボタンを押して、ダイアログに従ってインストール 5.3 よく使うパッケージのインストール tidyverseと呼ばれるパッケージをインストールしてみよう。 install.packages(&quot;tidyverse&quot;) 実はこのtidyverseはパッケージ群であり、複数のパッケージがインストールされる。 5.3.1 Tidyverseについて Tidyverseというパッケージ群はggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats, lubridateという複数のパッケージを含む たとえばggplot2は図を描くためのパッケージであり、plot()関数などとかぶる。実際に、ggplot2ではplot()と同じような図を出力することができる。Tidyverseシリーズは、データをより直感的に扱うための哲学に基づいて開発されており、Rオリジナルの関数ではないが、多くの人が使うパッケージ群となっておりRを学ぶならばほぼ必須といえる状態になりつつある。 5.4 パッケージの使い方1 パッケージの使い方は２通りある。 パッケージに入っている関数を使うためには、パッケージを読み込む ## library()でパッケージの読み込み library(tidyverse) 読み込んだ後は、パッケージに含まれている関数が普通に使える。 ## read_csvはtidyverseに入っているreadrというパッケージに含まれる data1 &lt;- read_csv(&quot;data/data1.csv&quot;) 一般的には、コード（Rスクリプト）を書く際に、コードの冒頭でパッケージを読みこんで置くことが一般的である。 # コードの例 # ライブラリ library(tidyverse) # データの読み込み data_634 &lt;- read_csv(&quot;data/hogehoge.csv&quot;) # データのサマリー summary(data_634) 5.5 パッケージの使い方2 読み込んでいないパッケージの関数を使おうとするとエラーが出る。 ## read_csvはtidyverseに入っているreadrというパッケージに含まれる data1 &lt;- read_csv(&quot;data/data1.csv&quot;) ## Error in read_csv(&quot;data/data1.csv&quot;): could not find function &quot;read_csv&quot; パッケージ名と関数名を::で繋ぐと、読み込んでいなくても使える。 data1 &lt;- readr::read_csv(&quot;data/data1.csv&quot;) これが２つ目のパッケージの使い方である。 そのスクリプトであまり使わないが一回だけ使いたいケースや、一般的でないパッケージや関数なので何のパッケージに入っている関数なのかを明示したい際に使う。 5.6 パッケージの注意点 パッケージは一旦インストールすると、Rには入っているが、使う際にはlibraryで読み込むか、2の方法で呼び出す必要がある。 Rのバージョンを更新（新しいRをインストール）すると、過去にダウンロードしたパッケージをインストールし直す必要があるので、もしRを更新した場合は注意しよう。 "],["datahandling.html", "Chapter 6 データのハンドリング 6.1 データ 6.2 データの読み込み 6.3 tidy data (整然データ) 6.4 データフレームを扱うテクニック：パイプ 6.5 tidyでないデータとtidyデータの変換 6.6 データの「大きさ」 6.7 列の名前一覧 6.8 変数の要約 6.9 変数の取り出し 6.10 変数の取り出しと計算 6.11 データの操作 6.12 練習問題: データ操作 6.13 データの結合", " Chapter 6 データのハンドリング 6.1 データ Rはデータ分析（統計解析）を行うのが主な機能 それ以外も色々できるが… 6.1.1 データとは？ 構造化データと非構造化データ 構造化：定義済みの形式に整理されている（行列で定義できる） 非構造化：形式化が難しい（テキストデータ、音声データなど） 半構造化データ：ある程度の構造は持つが、データベースのような形式になっていないもの（例：xml, json) Rでは基本的に構造化データを扱う テキストデータなども扱えるが、授業では扱わない 6.1.2 データフレーム Rでは基本的にデータをデータフレームという形で扱う データフレームは行と列を持つ形式 6.1.3 行と列 行と列は方向が決まっている。横が行(row)、縦が列(column)である。 行と列の覚え方 6.1.4 きれいなデータ？ 人間の見やすいデータ形式(表)とコンピュータが処理しやすいデータ形式は異なる。 同じ情報をもつデータフレームであっても、形式が異なるものがあることを理解しよう。 冒頭で出た武蔵大学経済学部の学生数のデータを見てみよう。 6.2 データの読み込み データはデータファイルから読み込む ファイルがある場所のpathを指定する。 データファイルの形式はExcelや.csv, .dta, .rdsなど様々 形式によって使う関数が異なる。 例えば Excelなら、readxlパッケージのread_excel csvなら、readrパッケージのread_csv いずれもtidyverseパッケージ群に含まれている ここではエクセル形式について説明するが、その他のファイル形式については私達のRの第8章を参照してほしい 6.2.1 演習: データの読み込み csvを読み込むにはread_excel()関数を使う。この関数はreadxlパッケージ含まれている。 readxlパッケージをインストールする。 r_renshuフォルダにdataフォルダを作成し、武蔵大学経済学部の学生数データをこちらからダウンロードして保存するか、以下のコードを実行する。 # data ディレクトリの作成 fs::dir_create(&quot;data&quot;) # データのダウンロードと保存 download.file(url=&quot;https://keita43a.github.io/regression_tutorial/data/musashi_keizai_students_2023.xlsx&quot;, destfile = &quot;data/musashi_keizai_students_2023.xlsx&quot;) Rスクリプトを作成し、data_mgt.Rという名前をつけて保存する。 Rスクリプトの冒頭でパッケージを読み込む library(tidyverse) library(readxl) Rスクリプトに以下のコードを書きこみ、データを読み込む。 data_634 &lt;- read_excel(&quot;data/musashi_keizai_students_2023.xlsx&quot;) Error: path does not exist:’というエラーが出る場合は、ファイルの相対パスが間違っている可能性がある r_renshuプロジェクトを開いていることを確認する getwd()で自分がr_renshuフォルダにいることを確認する musashi_keizai_students_2023.xlsxがきちんとdataフォルダに入っていることを確認する 6.2.2 日本語のデータを読み込む際の注意点 日本語のファイルを読み込む時に、問題になる可能性があるのがエンコーディングである。 エンコーディングとは、データを一定の規則に従って目的の情報に変換することで、とくに文字を扱う上で、それぞれの文字に番号を割り当てる符号化を行っている。 最近ではよりグローバルなUnicodeが使われており、tidyverseのパッケージもunicodeあるUTF-8をデフォルトとして使用する。しかし、日本語のファイルの中にはShift-JISというエンコーディングで作成されているファイルもある。 例えば、こちらのファイルをそのまま読み込んで見る。 product_cp932 = read_csv(&quot;data/Products_cp932.csv&quot;) product_cp932 ## # A tibble: 6 × 6 ## ...1 ProductID ProductName Price Category CreatedDate ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; ## 1 1 1 YKDJw 1122 &quot;\\x83w\\x83\\x8b\\x83X&amp;\\x83r\\x83\\x85\\x81[\\x83e\\x83B\\x81[&quot; 2005-08-30 ## 2 2 2 ftKQ7 1877 &quot;\\x83w\\x83\\x8b\\x83X&amp;\\x83r\\x83\\x85\\x81[\\x83e\\x83B\\x81[&quot; 2006-07-01 ## 3 3 3 l8lqm 3754 &quot;\\x89\\xc6\\x8b\\xef\\x81E\\x83C\\x83\\x93\\x83e\\x83\\x8a\\x83A\\x81E\\x89\\xc6\\x93d&quot; 2005-05-26 ## 4 4 4 8ntvc 8242 &quot;\\x89\\xd4\\x81E\\x83O\\x83\\x8a\\x81[\\x83\\x93&quot; 2005-09-06 ## 5 5 5 HhDBS 4461 &quot;\\x90H\\x95i&quot; 2010-12-28 ## 6 6 6 PKIs3 4963 &quot;\\x8eG\\x89\\xdd\\x81E\\x93\\xfa\\x97p\\x95i&quot; 2005-02-09 Categoryという変数が文字化けしてしまっているのがわかる。 ファイルのエンコーディングを調べることができる。 readrパッケージもに入っているguess_encodingを使うと、Shift-JISである可能性が高いことがわかる。 guess_encoding(&quot;data/Products_cp932.csv&quot;) ## # A tibble: 3 × 2 ## encoding confidence ## &lt;chr&gt; &lt;dbl&gt; ## 1 Shift_JIS 1 ## 2 windows-1252 0.31 ## 3 windows-1250 0.31 read_csvのオプションを使って、encodingを指定する。Shift-JISはCP932というエンコーディングになっている。 product_enc = read_csv(&quot;data/Products_cp932.csv&quot;, locale=locale(encoding=&quot;CP932&quot;)) product_enc ## # A tibble: 6 × 6 ## ...1 ProductID ProductName Price Category CreatedDate ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; ## 1 1 1 YKDJw 1122 ヘルス&amp;ビューティー 2005-08-30 ## 2 2 2 ftKQ7 1877 ヘルス&amp;ビューティー 2006-07-01 ## 3 3 3 l8lqm 3754 家具・インテリア・家電 2005-05-26 ## 4 4 4 8ntvc 8242 花・グリーン 2005-09-06 ## 5 5 5 HhDBS 4461 食品 2010-12-28 ## 6 6 6 PKIs3 4963 雑貨・日用品 2005-02-09 文字化けなく読み込めた。 6.2.3 readrのその他のオプション readrでは以下のオプションを引数に指定することで設定できる。 引数 デフォルトの値 意味 col_names TRUE 1行目を列名にするか na c(““,”NA”) 欠損値を表す文字列 comment “” コメント開始文字 skip 0 先頭何行を無視するか n_max Inf 何行目までを読み込むか trim_ws TRUE 前後の空白文字を無視するか 6.3 tidy data (整然データ) 武蔵大学経済学部の学生数データを見てみよう。 学科 性別 4年 3年 2年 1年 経済学科 男 140 121 139 133 経済学科 女 38 46 50 38 経営学科 男 117 111 121 129 経営学科 女 52 62 53 62 金融学科 男 108 107 90 93 金融学科 女 24 33 29 36 ## エクセルからデータを読み込み data_634 &lt;- read_excel(&quot;data/musashi_keizai_students_2023.xlsx&quot;) knitr::kable(data_634) ## kableは見やすい表を出力する関数 このデータは、人間の目に見やすい形式になっている。学科・性別と学年がクロス表形式になっているため、何年生の何学科の男女が何人いるか見やすい表になっている。このような形のデータは横型(wide型)と呼ばれる。 同じデータを、異なる形式で表示したものが以下である。 print(as.data.frame(data_634_long)) ## 学科 性別 学年 学生数 ## 1 経済学科 男 1年 133 ## 2 経済学科 男 2年 139 ## 3 経済学科 男 3年 121 ## 4 経済学科 男 4年 140 ## 5 経済学科 女 1年 38 ## 6 経済学科 女 2年 50 ## 7 経済学科 女 3年 46 ## 8 経済学科 女 4年 38 ## 9 経営学科 男 1年 129 ## 10 経営学科 男 2年 121 ## 11 経営学科 男 3年 111 ## 12 経営学科 男 4年 117 ## 13 経営学科 女 1年 62 ## 14 経営学科 女 2年 53 ## 15 経営学科 女 3年 62 ## 16 経営学科 女 4年 52 ## 17 金融学科 男 1年 93 ## 18 金融学科 男 2年 90 ## 19 金融学科 男 3年 107 ## 20 金融学科 男 4年 108 ## 21 金融学科 女 1年 36 ## 22 金融学科 女 2年 29 ## 23 金融学科 女 3年 33 ## 24 金融学科 女 4年 24 このデータでは「人数」という一つの変数のみの列があり、その他の属性もすべて縦の項目で表されている。これは、コンピューターによって処理しやすい形式であり、ベクトルの処理が得意なRでは縦長の形式が扱いやすい。 この縦長形式のデータをtidy data(整然データ)と呼ぶ tidy dataの定義 一つの列が一つの変数を表す 一つの行が一つの観測を表す 一つのテーブルが一つのデータセットだけを含む Rの中でもtidy dataでないデータが好ましい場合もある。しかし、tidy dataを基本にしておけば、そこから加工することは容易である。 6.4 データフレームを扱うテクニック：パイプ データフレームを操作する関数の共通点 第１引数がデータフレーム 第２引数以降はそのデータフレームに対する操作 結果がデータフレームとして返される 6.4.1 パイプ パイプ(|&gt;)は「これまでの処理を次の第１引数として引き渡す」という機能を持つ。 パイプはかつて%&gt;%と書かれていて、tidyverse群の一つであるmagrittrパッケージの関数であった。新しい|&gt;という演算子はRにネイティブで入っているため、パッケージをロードしなくても使える。少し前のコードだと未だに%&gt;%と書いてあるかもしれないが基本的に同じ意味である（阿部はまだ癖で書いてしまう時がある）。 x1 &lt;- c(1,2,3,4,5) ## 以下の２つは同じことを行っている。 mean(x1) x1 |&gt; mean() ## |&gt; はパイプと呼ばれるもの 6.5 tidyでないデータとtidyデータの変換 学科 男 女 経済学科 533 172 経営学科 478 229 金融学科 398 122 今から横型（wide型）のデータを縦長（long型）に変換する。上のようなデータを下のようなデータに変換したいとする。 学科 性別 人数 経済学科 男 533 経済学科 女 172 経営学科 男 478 経営学科 女 229 金融学科 男 398 金融学科 女 122 6.5.1 long型データへの変換 tidyrというパッケージのpivot_longerという関数はtidyでないデータ(wide型)をtidyなデータ(long型)に変換する。 まずパイプ(|&gt;)でdata_634というwide型のデータをpivot_longer()関数に引き渡す。 pivot_longer() 関数には、まず以下の3つの引数が重要である。 colsは、どの列(column)の変数を使うかを指定する names_toは、新たに生成されるカテゴリ用の列の名前を指定する values_toは、数値が入る列の名前を指定する さらに複雑な操作をする場合は他にも引数を使うことがあるが、基本的な変換は上の三つできちんと指定されていればうまくいくはずだ。 data_634_long &lt;- data_634 |&gt; ## long型に変換。1年〜４年の列(cols)を学生数という列にvalues_toでまとめる。各行に何年生かnames_toで記録する。 pivot_longer( cols=c(&quot;1年&quot;,&quot;2年&quot;,&quot;3年&quot;,&quot;4年&quot;), names_to =&quot;学年&quot;, values_to = &quot;学生数&quot;) 6.5.2 データを見てみる 右上のEnvironmentペーンにdata_634_longというオブジェクトが生成される。 クリックしてみると、エクセルのような画面が現れる またView()という関数をつかっても、同じようにデータを見ることができる。 ## data_634_longを見るビューワーがRstudio上で開く View(data_634_long) 6.5.3 データを一部だけみたい場合 また、データの最初だけみたいときは、head(), また後ろだけ見たいときはtail()関数を使う。 デフォルトでは、6行だけ表示されるが、行数は引数nで調整できる。 ## data1の最初の10行がコンソールに表示される head(data_634_long, n=10) ## # A tibble: 10 × 4 ## 学科 性別 学年 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 133 ## 2 経済学科 男 2年 139 ## 3 経済学科 男 3年 121 ## 4 経済学科 男 4年 140 ## 5 経済学科 女 1年 38 ## 6 経済学科 女 2年 50 ## 7 経済学科 女 3年 46 ## 8 経済学科 女 4年 38 ## 9 経営学科 男 1年 129 ## 10 経営学科 男 2年 121 6.6 データの「大きさ」 データの行数や列数を調べるときにはdim()関数を使う。 dim(data_634_long) ## [1] 24 4 24行、4列だとわかる。 RStudioではdata.frameオブジェクトは右上ペーンにも表示されている。 6.7 列の名前一覧 データの各変数名（列名）の一覧を見たい場合はnames()かcolnames() names(data_634_long) ## [1] &quot;学科&quot; &quot;性別&quot; &quot;学年&quot; &quot;学生数&quot; 6.8 変数の要約 含まれている変数の基本統計量を見たい場合はsummary()関数を使う。 summary(data_634_long) ## 学科 性別 学年 学生数 ## 経済学科:8 男:12 1年:6 Min. : 24.0 ## 経営学科:8 女:12 2年:6 1st Qu.: 44.0 ## 金融学科:8 3年:6 Median : 76.0 ## 4年:6 Mean : 80.5 ## 3rd Qu.:118.0 ## Max. :140.0 定性的なデータ（カテゴリ変数）は、入っているカテゴリとその数 もしcharacterと表示されていたら、単なる文字列と認識されている 定量的なデータは以下のような統計量が計算される。 Min. nth Qu. Median Mean Max. 最小 n分位 中央値 平均 最大 6.9 変数の取り出し データから変数を一つ取り出すときは$マークを使う。 ## データフレーム$変数 で変数の列をベクトルとして取り出す data_634_long$学年 ## [1] 1年 2年 3年 4年 1年 2年 3年 4年 1年 2年 3年 4年 1年 2年 3年 4年 1年 2年 3年 4年 1年 2年 3年 4年 ## Levels: 1年 2年 3年 4年 6.10 変数の取り出しと計算 ## 平均 mean()関数 mean(data_634_long$学生数) ## [1] 80.5 ## 中央値 median()関数 median(data_634_long$学生数) ## [1] 76 ## 分散 var()関数 var(data_634_long$学生数) ## [1] 1625.478 ## 合計 sum()関数 sum(data_634_long$学生数) ## [1] 1932 6.11 データの操作 データを編集したいことはたくさん出てくる。 列の名前を変えたい データの特定の列だけ抽出したい データの特定の行だけ提出したい 例：男性だけのデータ データの順番を並び替えたい データの列を並び替えたい 新しい変数を作りたい データを集計したい 6.11.1 データの操作 tidyverseシリーズであるdplyrパッケージに入っている関数で操作することができる。 6.11.2 元のデータの見た目確認 print(data_634_long) ## # A tibble: 24 × 4 ## 学科 性別 学年 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 133 ## 2 経済学科 男 2年 139 ## 3 経済学科 男 3年 121 ## 4 経済学科 男 4年 140 ## 5 経済学科 女 1年 38 ## 6 経済学科 女 2年 50 ## 7 経済学科 女 3年 46 ## 8 経済学科 女 4年 38 ## 9 経営学科 男 1年 129 ## 10 経営学科 男 2年 121 ## # ℹ 14 more rows 6.11.3 列の名前を変えたい: rename() 列（変数）の名前を変更する data_634_long_eng &lt;- data_634_long |&gt; rename(department = 学科, grade = 学年, gender = 性別, stu_num = 学生数) print(data_634_long_eng) ## # A tibble: 24 × 4 ## department gender grade stu_num ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 133 ## 2 経済学科 男 2年 139 ## 3 経済学科 男 3年 121 ## 4 経済学科 男 4年 140 ## 5 経済学科 女 1年 38 ## 6 経済学科 女 2年 50 ## 7 経済学科 女 3年 46 ## 8 経済学科 女 4年 38 ## 9 経営学科 男 1年 129 ## 10 経営学科 男 2年 121 ## # ℹ 14 more rows 6.11.4 特定の列だけ抽出する: select() データのうち、学科と性別という変数だけ抽出したいとする data_634_long_select &lt;- data_634_long |&gt; select(学科, 性別) print(data_634_long_select) ## # A tibble: 24 × 2 ## 学科 性別 ## &lt;fct&gt; &lt;fct&gt; ## 1 経済学科 男 ## 2 経済学科 男 ## 3 経済学科 男 ## 4 経済学科 男 ## 5 経済学科 女 ## 6 経済学科 女 ## 7 経済学科 女 ## 8 経済学科 女 ## 9 経営学科 男 ## 10 経営学科 男 ## # ℹ 14 more rows 6.11.5 特定の行だけ抽出する: filter() データのうち、女性のデータだけを抽出したいとする data_634_long_filter &lt;- data_634_long |&gt; filter(性別 == &quot;女&quot;) print(data_634_long_filter) ## # A tibble: 12 × 4 ## 学科 性別 学年 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 女 1年 38 ## 2 経済学科 女 2年 50 ## 3 経済学科 女 3年 46 ## 4 経済学科 女 4年 38 ## 5 経営学科 女 1年 62 ## 6 経営学科 女 2年 53 ## 7 経営学科 女 3年 62 ## 8 経営学科 女 4年 52 ## 9 金融学科 女 1年 36 ## 10 金融学科 女 2年 29 ## 11 金融学科 女 3年 33 ## 12 金融学科 女 4年 24 6.11.6 データの順番を並び替える: arrange() データの順番を学年-&gt;性別の順番で並び替える data_634_long_arrange &lt;- data_634_long |&gt; arrange(学年, 性別) print(data_634_long_arrange) ## # A tibble: 24 × 4 ## 学科 性別 学年 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 133 ## 2 経営学科 男 1年 129 ## 3 金融学科 男 1年 93 ## 4 経済学科 女 1年 38 ## 5 経営学科 女 1年 62 ## 6 金融学科 女 1年 36 ## 7 経済学科 男 2年 139 ## 8 経営学科 男 2年 121 ## 9 金融学科 男 2年 90 ## 10 経済学科 女 2年 50 ## # ℹ 14 more rows 6.11.6.1 降順の並びにする デフォルトは昇順だが、desc()で降順で並び変えることもできる data_634_long_arrange2 &lt;- data_634_long |&gt; arrange(desc(学年), 性別) print(data_634_long_arrange2) ## # A tibble: 24 × 4 ## 学科 性別 学年 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 男 4年 140 ## 2 経営学科 男 4年 117 ## 3 金融学科 男 4年 108 ## 4 経済学科 女 4年 38 ## 5 経営学科 女 4年 52 ## 6 金融学科 女 4年 24 ## 7 経済学科 男 3年 121 ## 8 経営学科 男 3年 111 ## 9 金融学科 男 3年 107 ## 10 経済学科 女 3年 46 ## # ℹ 14 more rows 6.11.7 データの列を並び替える: relocate() 学年の列を性別の前に持ってくる data_634_long_relocate &lt;- data_634_long |&gt; relocate(学年, .before=性別) print(data_634_long_relocate) ## # A tibble: 24 × 4 ## 学科 学年 性別 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 1年 男 133 ## 2 経済学科 2年 男 139 ## 3 経済学科 3年 男 121 ## 4 経済学科 4年 男 140 ## 5 経済学科 1年 女 38 ## 6 経済学科 2年 女 50 ## 7 経済学科 3年 女 46 ## 8 経済学科 4年 女 38 ## 9 経営学科 1年 男 129 ## 10 経営学科 2年 男 121 ## # ℹ 14 more rows 6.11.7.1 列の後ろに持ってくる場合 学年の列を学科の後に持ってくる data_634_long_relocate2 &lt;- data_634_long |&gt; relocate(学年, .after=学科) print(data_634_long_relocate2) ## # A tibble: 24 × 4 ## 学科 学年 性別 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 1年 男 133 ## 2 経済学科 2年 男 139 ## 3 経済学科 3年 男 121 ## 4 経済学科 4年 男 140 ## 5 経済学科 1年 女 38 ## 6 経済学科 2年 女 50 ## 7 経済学科 3年 女 46 ## 8 経済学科 4年 女 38 ## 9 経営学科 1年 男 129 ## 10 経営学科 2年 男 121 ## # ℹ 14 more rows 6.11.8 データの列を追加する: mutate() 新しく、学生数を100で割った数値を作るとする data_634_long_mutate &lt;- data_634_long |&gt; mutate(学生数100 = 学生数/100) print(data_634_long_mutate) ## # A tibble: 24 × 5 ## 学科 性別 学年 学生数 学生数100 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 133 1.33 ## 2 経済学科 男 2年 139 1.39 ## 3 経済学科 男 3年 121 1.21 ## 4 経済学科 男 4年 140 1.4 ## 5 経済学科 女 1年 38 0.38 ## 6 経済学科 女 2年 50 0.5 ## 7 経済学科 女 3年 46 0.46 ## 8 経済学科 女 4年 38 0.38 ## 9 経営学科 男 1年 129 1.29 ## 10 経営学科 男 2年 121 1.21 ## # ℹ 14 more rows 6.11.9 データの列を編集する: mutate() 存在する変数名にすると、新しく変数(列)を作らずに上書きする data_634_long_mutate2 &lt;- data_634_long |&gt; mutate(学生数 = 学生数/100) print(data_634_long_mutate2) ## # A tibble: 24 × 4 ## 学科 性別 学年 学生数 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 1.33 ## 2 経済学科 男 2年 1.39 ## 3 経済学科 男 3年 1.21 ## 4 経済学科 男 4年 1.4 ## 5 経済学科 女 1年 0.38 ## 6 経済学科 女 2年 0.5 ## 7 経済学科 女 3年 0.46 ## 8 経済学科 女 4年 0.38 ## 9 経営学科 男 1年 1.29 ## 10 経営学科 男 2年 1.21 ## # ℹ 14 more rows 6.11.10 データを集計する 任意を列を集計したり統計量を計算する。 data_634_long_summarise &lt;- data_634_long |&gt; summarise(学生数合計 = sum(学生数), 学生数平均 = mean(学生数)) print(data_634_long_summarise) ## # A tibble: 1 × 2 ## 学生数合計 学生数平均 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1932 80.5 6.11.11 データ操作の応用：パイプによる引き渡し ある操作を行った結果をパイプで次の関数に引き渡す。 ## 女性の合計だけを知りたい data_634_long_female &lt;- data_634_long |&gt; filter(性別==&quot;女&quot;) |&gt; summarise(女性学生数合計 = sum(学生数)) print(data_634_long_female) ## # A tibble: 1 × 1 ## 女性学生数合計 ## &lt;dbl&gt; ## 1 523 6.11.12 データ操作の応用：グループごとの集計 グループごとに集計したい場合はgroup_byでグループ情報を与える ## 学科ごとに合計を計算 data_634_long_dept &lt;- data_634_long |&gt; group_by(学科) |&gt; summarise(学生数合計 = sum(学生数)) print(data_634_long_dept) ## # A tibble: 3 × 2 ## 学科 学生数合計 ## &lt;fct&gt; &lt;dbl&gt; ## 1 経済学科 705 ## 2 経営学科 707 ## 3 金融学科 520 6.12 練習問題: データ操作 武蔵大学経済学部の学生数データを使って、女性のみの合計学生数を学年別で計算せよ。結果をdata_634_long_female_gradeというオブジェクトに格納し、結果をコンソールに表示せよ。 同じデータを使って、１,２年生のみ合計学生数を男女別・学年別で計算せよ。結果をdata_634_long_1_2_gradeというオブジェクトに格納し、結果をコンソールに表示せよ。 6.13 データの結合 ２つのデータフレームを結合したい場合 縦に結合したい場合 横に結合したい場合 6.13.1 データの縦の結合 例えば人文学部のデータと結合したいとする。 人文学部のデータはこちらからダウンロードできる。 ## エクセルからデータを読み込み data_634_jinbun &lt;- readxl::read_excel(&quot;docs/data/musashi_jinbun_students_2023.xlsx&quot;) knitr::kable(data_634_jinbun) ## kableは見やすい表を出力する関数 学科 性別 4年 3年 2年 1年 英語英米文化学科 男 53 73 65 51 英語英米文化学科 女 74 72 77 55 ヨーロッパ文化学科 男 43 47 37 68 ヨーロッパ文化学科 女 60 66 63 56 日本・東アジア文化学科 男 50 46 48 45 日本・東アジア文化学科 女 61 78 75 74 変数の順番などが同じことを確認した上で、bind_rows()を使う data_634_keizai_jinbun &lt;- bind_rows(data_634,data_634_jinbun) print(data_634_keizai_jinbun) ## # A tibble: 12 × 6 ## 学科 性別 `4年` `3年` `2年` `1年` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 経済学科 男 140 121 139 133 ## 2 経済学科 女 38 46 50 38 ## 3 経営学科 男 117 111 121 129 ## 4 経営学科 女 52 62 53 62 ## 5 金融学科 男 108 107 90 93 ## 6 金融学科 女 24 33 29 36 ## 7 英語英米文化学科 男 53 73 65 51 ## 8 英語英米文化学科 女 74 72 77 55 ## 9 ヨーロッパ文化学科 男 43 47 37 68 ## 10 ヨーロッパ文化学科 女 60 66 63 56 ## 11 日本・東アジア文化学科 男 50 46 48 45 ## 12 日本・東アジア文化学科 女 61 78 75 74 6.13.2 データを横に統合 新しい変数を含んだデータを既存のデータに統合したい ## エクセルからデータを読み込み data_634_keizai_teiin &lt;- readxl::read_excel(&quot;docs/data/musashi_keizai_teiin_2023.xlsx&quot;) knitr::kable(data_634_keizai_teiin) ## kableは見やすい表を出力する関数 学科 定員 経済学科 580 経営学科 580 金融学科 440 6.13.3 データを横に統合：join()関数 ここではleft_joinを使う。学科という変数をキーとして、左側に存在するすべての行にデータを統合する。 ## 学科の人数と学科の定員を統合する data_634_long_keizai &lt;- data_634_long |&gt; left_join(data_634_keizai_teiin, by=c(&quot;学科&quot;=&quot;学科&quot;)) print(data_634_long_keizai) ## # A tibble: 24 × 5 ## 学科 性別 学年 学生数 定員 ## &lt;chr&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 経済学科 男 1年 133 580 ## 2 経済学科 男 2年 139 580 ## 3 経済学科 男 3年 121 580 ## 4 経済学科 男 4年 140 580 ## 5 経済学科 女 1年 38 580 ## 6 経済学科 女 2年 50 580 ## 7 経済学科 女 3年 46 580 ## 8 経済学科 女 4年 38 580 ## 9 経営学科 男 1年 129 580 ## 10 経営学科 男 2年 121 580 ## # ℹ 14 more rows 6.13.4 join関数一覧 上で使用したleft_join以外にもいくつかのjoin関数が用意されている。 関数名 説明 inner_join() どちらのデータフレームにも存在するキーの行のみ返す left_join() 左のデータフレームに存在するキーの行を返す right_join() 右のデータフレームにも存在するキーの行を返す full_join() いずれかのデータフレームに存在するキーの行を返す "],["rstats.html", "Chapter 7 記述統計 7.1 統計とは 7.2 準備 7.3 データとは 7.4 代表的な統計量 7.5 Rによる記述統計のテクニック", " Chapter 7 記述統計 7.1 統計とは 統計学はおおまかに記述統計と推測統計の２つから成り立っている。記述統計は得られたデータからその特徴を抜き出す統計であり、推測統計は全体の把握が難しいような大きな対象やまだ起こっていないことなどに対して推測を行う統計である。 7.1.1 記述統計 記述統計の代表的なものに人口統計がある。その国や地域に現在人口が何人いるか？男女比は？年齢構成は？などの特徴を把握するための手続きである。 記述統計を行うためには、ヒストグラムなどのビジュアライゼーションと、平均値・標準偏差などの統計量による記述の方法がある。 7.1.2 推測統計 たとえば、日本人全員の身長を知ろうとして、全員を調査するのは難しい。しかし、全員を調査をできなくても、一部の人を調査することで全体を推測することができる。 身近なものには選挙の当確がある。例えば、AさんとBさんのいずれかを選ぶ投票を行い、1万人が投票したとする。過半数を取らないと当選にならないので、少なくともいずれかが5000票獲得するまでは勝負は決まらない。しかし、開票率１％で当確が出ることがある。1万票の１％は100票である。それだけしか開票していないのになぜ「当選確実」といえるのだろうか。  票が入った箱をよく混ぜてそこから100票を取り出すとしよう。そして、90票がAさんで、のこり10票がBさんだったどうだろうか。おそらくAさんが勝つだろうということになる。かなり高い確率で、残りの9900票の多数もAさんに投票されていると考えるのが妥当だからだ。もちろん確率の問題であるため、当確が取り消されることもまれにある。しかし、ある程度の間違いがあるとしたうえで、まだわからないもの、もしくは規模が大きすぎてわからないものを少ないサンプルで推測しようとするのが推測統計である。    このような推測統計を行う際には「よく混ぜる」ことが重要である。イメージとしてはコーヒーにミルクを混ぜる場合である。しっかりとかき混ぜれば、スプーンで掬った一部とカップの中は同じ濃さのはずであるが、きちんと混ざっていなければ、まだ良く混ざっていないコーヒーの部分を掬ってもカップの中の味を再現することはできない。 7.2 準備 あらたにRスクリプトを作成し、stats.Rという名前をつけて保存する。 そして、以下のライブラリを読み込んでおく。ライブラリがなくてエラーが出る場合はインストールしてから再度読み込む。 library(tidyverse) library(psych) library(skimr) # もしインストールしてない場合は、Rstudioの右下ペーンのPackagesタブからインストールするか、以下のコード install.packages(&quot;psych&quot;) install.packages(&quot;skimr&quot;) 7.3 データとは 統計において分析する対象はデータである。データには様々な形があるが、一般的には数値や文字情報の集まりである。 以下のコードを実行してみよう。すると、100個の数値が並ぶ。これをランダムにサンプリングして計測した日本人男性の身長だとしよう。 set.seed(3) height &lt;- rnorm(100,mean=170,sd=10) |&gt; round() height ## [1] 160 167 173 158 172 170 171 181 158 183 163 159 163 173 172 167 160 164 182 172 164 161 168 153 165 163 182 180 169 159 179 179 177 177 166 177 183 170 160 ## [40] 178 178 167 187 162 173 147 168 181 165 161 177 162 173 153 156 165 160 184 179 162 176 179 173 174 182 165 166 180 157 172 170 175 180 173 172 177 182 174 ## [79] 160 168 187 166 177 182 178 170 172 161 174 161 161 160 163 181 166 169 165 175 179 168 この数字を見てどう思うか？ 「ああ、数字が並んでいるなぁ」 「自分はこの中では高いほうかな」 などと思うかもしれない。 まず、身長はみんな同じではない。言い換えると、様々な数値を取る。これを分布すると呼ぶ。 なぜ数値は分布するのだろうか。それは、データを生み出す背景に不確実性があるから。日本人男性の身長が決まるメカニズムが存在する。また個々人で条件が異なる。そういった背景が身長という数値となって現れている。 一方で、数字の決まり方には特徴や癖がある。たとえば身長1cmや身長100mの人はいない。「普通」の身長に近いひとは多く、特に低い人や高い人は数としては少ない。こういった分布の特性がある。どうやって特徴や癖を把握すればいいのか？ 数字がざっと並んでいるだけでは、イマイチよくわからない。そこで、生データ（生の現実）から、特徴や癖を引き出す手法が統計なのである。 ではどのように特徴や癖を引き出すか。これにはデータの縮約を行う。 縮約とはデータとして並んでいるたくさんの数字を、なにかの基準で整理整頓して、意味のある情報だけを抽出することである。 縮約には大きく分けて二つの方法がある。一つ目は、1つの数字で特徴を代表させる方法である。この代表される数字を統計量である。二つ目は、グラフ化してその特徴をとらえようとすることである。近年ではVisualizationとも呼ばれる。 この章では代表的な統計量をおさらいし、そのRでの計算方法を学ぶ。 7.4 代表的な統計量 7.4.1 数式 まず、数式の読み方について簡単におさらいする。数式は英語と同じで意味がわかれば怖いものではないので、一つずつ確認しよう。 統計学では、データを表現するのによく文字を使う。例えば\\(x\\)である。しかし、データが100個ある場合には、\\(x_{1},x_{2},\\ldots,x_{100}\\)といったように、右下に添え字をつけてデータを区別する。このとき、一般的な言い方をするために\\(i\\)番目のデータを\\(x_{i}\\)と表記することがある。 ここで、厳密には統計量ではないが、データの合計の計算方法を勉強しよう。 例えば上の身長の例のように、100個のデータを合計するためには、100個の数値を足す必要がある。それを数式で表現すると、 \\[ x_1 + x_2 + x_3 +\\cdots + x_{100} \\] のように、100個の数字を書く必要があるが、現実には書けない。 そこで、数列の和の記号であるシグマを使う。 \\[ \\sum^{100}_{i=1}x_i = x_1 + x_2 + x_3 +\\cdots + x_{100} \\] 上の左辺のシグマ記号で書かれたものは、右辺と同じ意味である。 つまり上のシグマ記号\\(\\sum\\)は、「\\(i=1\\)から、\\(100\\)までの\\(x_i\\)を足し合わせる」という意味を持つ。 合計をRで計算するときには、sum()という関数を使って以下のようになる。ここではheightというオブジェクトに100個の数値を持つベクトルが入っているため、sum()はベクトルのすべての数値を足し合わせる。 sum(height) ## [1] 17008 7.4.2 平均 もっとも身近な統計量は平均であろう。統計学において平均値とは一般的に算術平均（相加平均）を指す。これはすべてのデータを合計し、それをデータの個数で割ることで求められる。 統計ではよくデータ\\(x_{i}\\)の平均を、\\(x\\)に棒をつけて\\(\\bar{x}\\)と表現する。 \\[ \\bar{x} = \\frac{1}{n}\\sum^{n}_{i=1}x_i \\] これをRで計算するときには、mean()という関数が用意されている。 mean(height) ## [1] 170.08 7.4.3 中央値 中央値は、一言でいうと「真ん中」にある数値である。数値を小さい順に並べ、その真ん中にある数値を代表値として選ぶ。これは平均値と一致することもあれば、異なることもある。 もう少し厳密に定義すると、 \\(n\\)個の観測値からなるデータ(\\(x_1,x_2,\\ldots,x_n\\))を小さい順に並べたものを(\\(x_1&#39;,x_2&#39;,\\ldots,x_{n}&#39;\\)) とする。中央値\\(Q_{\\frac{1}{2}}\\)は \\[ Q_{\\frac{1}{2}} = \\begin{cases} x_{\\frac{n}{2}} &amp; \\text{もし } n \\text{が奇数の場合} \\\\ \\frac{1}{2}(x_{\\frac{n}{2}} + x_{\\frac{n}{2}+1}) &amp; \\text{もし } n \\text{が偶数の場合} \\end{cases} \\] 難しく見えるかもしれないが、単純なことを行っている。\\(n\\),つまりデータの個数が奇数ならば、「真ん中」の数値が中央値となる。データの個数が5なら3番目, 99なら50番目である。 もし、データが偶数ならば、「真ん中」の数値はない。そこで、ちょうど真ん中を挟む二つの数字の平均を取る。100個のデータがあるならば、50番目と51番目の数字の平均を取ることで中央値とする。 Rでの計算はmedian()関数を用いる。medianは文字通り英語で中央値という意味である。 median(height) ## [1] 170 7.4.4 最大値・最小値 データの中で最も大きい数値、小さい数値もデータの特徴を表す。 Rではmax()関数, min()関数で算出できる。 # データの最大値 max(height) ## [1] 187 # データの最小値 min(height) ## [1] 147 7.4.5 分散 分散は、データのばらつきを示す統計量である。数値が大きければデータは互いに大きく異なる数値を取っており、小さけば近い数値を取っている。分散は、それぞれのデータの数値から平均値を引き、それを二乗することで求められる。 \\[ \\sigma^2 = \\frac{1}{n}\\sum^{n}_{i=1}( x_i - \\bar{x})^2 \\] Rで分散を計算する関数はデフォルトでは用意されていない。なぜないのかは、Section 9の不偏分散の項で説明する。 分散をRで計算すると、自分で数式を表現する必要があるが以下のようになる。 height_mean &lt;- mean(height) # heightの平均値 height_n &lt;- length(height) # heightのデータの個数 sigma2 = sum((height-height_mean)^2)/height_n sigma2 ## [1] 72.9936 7.4.6 もう一つの分散：不偏分散 不偏分散は同じくデータの散らばりを示す統計量である。標本分散と呼んだり、文脈によっては単に分散と呼んでこちらを指す場合もある。 詳しくは推定統計量の項で説明する。 分散との違いは、nで割るか、n-1で割るかの違いである。 \\[ s^2 = \\frac{1}{n-1}\\sum^{n}_{i=1}( x_i - \\bar{x})^2 \\] Rではvar()関数で計算できる。 s2 = var(height) s2 ## [1] 73.73091 7.4.7 標準偏差 標準偏差もデータのばらつきを表す。 分散もばらつきを表す統計量なので、なぜ二つあるのか？と思うかもしれない。 分散は、データのばらつきを二乗してから合計してデータ数で割っている。そのため、数値大きさはばらつきを示すが、その数値の単位は二乗されてしまっている。身長のケースで言えば\\(cm^2\\)となっているのである。 これでは平均に対してばらつきが大きいのか小さいのかわかりにくい。 そこで、標準偏差は分散の平方根（ルート）を取ることで、計算される。 二乗のルートなので、単位がもとに戻って解釈しやすくなるのである。 \\[ \\sigma = \\sqrt{\\sigma^2} \\] ここでは単純に上で計算した分散のルーとしてを計算しよう。ルートはsqrt()という関数で計算できる。 sigma = sqrt(sigma2) sigma ## [1] 8.543629 7.4.8 不偏標準偏差 標準偏差を計算するために、不偏分散を用いたものが不偏標準偏差である。標本標準偏差と呼ばれたり、文脈によっては単に標準偏差とよんでこちらを指す場合もある。 以下の記述統計などではこちらが一般的に使われる。 理由は推定統計量の項を参照してほしい。 \\[ s = \\sqrt{s^2} \\] 不偏標準偏差は上と同様にルートでも計算できるが、sd()という関数が用意されている。確認するために、いずれの方法でも計算してみよう。 s = sqrt(s2) s ## [1] 8.58667 sd関数を使う場合 s = sd(height) s ## [1] 8.58667 7.5 Rによる記述統計のテクニック ここでは、簡単に記述統計を示すテクニックを紹介する。 データ分析を行う上で、手元のデータがどういうデータなのかを記述統計で見るのは重要である。 また、論文にする際にも、まずはデータの説明として記述統計表を示すのが一般的である。 7.5.1 使用するデータ ここではRにもともと入っているmtcarsというデータを使用する。 1974年にアメリカのMotor Trendという雑誌に掲載された燃費などの性能を比較したデータである。 例えばmpgは燃費（１ガロン当たりのマイル）、cylはシリンダーの数、hpはエンジンの馬力、wtは重さ、などである。 詳しく知りたい人は、RStudioの右下ペーンの[Help]タブから、mtcarsと検索してみよう。 data(mtcars) #データの呼び出し mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 7.5.2 summary関数 summaryというRデフォルトの関数(base関数と呼ぶ)を使うと、最小・最大・平均・中央値・四分位点などが表示される。 summary(mtcars) ## mpg cyl disp hp drat wt qsec vs am ## Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 Min. :0.0000 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 1st Qu.:0.0000 ## Median :19.20 Median :6.000 Median :196.3 Median :123.0 Median :3.695 Median :3.325 Median :17.71 Median :0.0000 Median :0.0000 ## Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 Mean :0.4062 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 3rd Qu.:1.0000 ## Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 Max. :1.0000 ## gear carb ## Min. :3.000 Min. :1.000 ## 1st Qu.:3.000 1st Qu.:2.000 ## Median :4.000 Median :2.000 ## Mean :3.688 Mean :2.812 ## 3rd Qu.:4.000 3rd Qu.:4.000 ## Max. :5.000 Max. :8.000 7.5.3 describe関数 describe関数を使うと、簡単にデータ数(n)、平均、標準偏差や範囲を計算することができる。ここで計算されている標準偏差は不偏標準偏差である。 library(psych) describe(mtcars, skew=FALSE) ## vars n mean sd median min max range se ## mpg 1 32 20.09 6.03 19.20 10.40 33.90 23.50 1.07 ## cyl 2 32 6.19 1.79 6.00 4.00 8.00 4.00 0.32 ## disp 3 32 230.72 123.94 196.30 71.10 472.00 400.90 21.91 ## hp 4 32 146.69 68.56 123.00 52.00 335.00 283.00 12.12 ## drat 5 32 3.60 0.53 3.70 2.76 4.93 2.17 0.09 ## wt 6 32 3.22 0.98 3.33 1.51 5.42 3.91 0.17 ## qsec 7 32 17.85 1.79 17.71 14.50 22.90 8.40 0.32 ## vs 8 32 0.44 0.50 0.00 0.00 1.00 1.00 0.09 ## am 9 32 0.41 0.50 0.00 0.00 1.00 1.00 0.09 ## gear 10 32 3.69 0.74 4.00 3.00 5.00 2.00 0.13 ## carb 11 32 2.81 1.62 2.00 1.00 8.00 7.00 0.29 7.5.4 skim関数 skim関数を使うと、記述統計に加えて簡単なヒストグラムも図示してくれる。ここで計算されている標準偏差は不偏標準偏差である。 library(skimr) skim(mtcars) Table 7.1: Data summary Name mtcars Number of rows 32 Number of columns 11 _______________________ Column type frequency: numeric 11 ________________________ Group variables None Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist mpg 0 1 20.09 6.03 10.40 15.43 19.20 22.80 33.90 ▃▇▅▁▂ cyl 0 1 6.19 1.79 4.00 4.00 6.00 8.00 8.00 ▆▁▃▁▇ disp 0 1 230.72 123.94 71.10 120.83 196.30 326.00 472.00 ▇▃▃▃▂ hp 0 1 146.69 68.56 52.00 96.50 123.00 180.00 335.00 ▇▇▆▃▁ drat 0 1 3.60 0.53 2.76 3.08 3.70 3.92 4.93 ▇▃▇▅▁ wt 0 1 3.22 0.98 1.51 2.58 3.33 3.61 5.42 ▃▃▇▁▂ qsec 0 1 17.85 1.79 14.50 16.89 17.71 18.90 22.90 ▃▇▇▂▁ vs 0 1 0.44 0.50 0.00 0.00 0.00 1.00 1.00 ▇▁▁▁▆ am 0 1 0.41 0.50 0.00 0.00 0.00 1.00 1.00 ▇▁▁▁▆ gear 0 1 3.69 0.74 3.00 3.00 4.00 4.00 5.00 ▇▁▆▁▂ carb 0 1 2.81 1.62 1.00 2.00 2.00 4.00 8.00 ▇▂▅▁▁ "],["rviz.html", "Chapter 8 ビジュアライゼーションの基本 8.1 Rにおける描画 8.2 準備 8.3 描画をしてみよう 8.4 復習：データ読み込み 8.5 描画の前に 8.6 キャンバスを用意する 8.7 グラフのレイヤーを追加する 8.8 文字化けに対処する 8.9 aesに色を追加する 8.10 男女の置き方を変えたい 8.11 色を変えたい 8.12 学科別に分けたい 8.13 ラベルを変更する・タイトルを追加する 8.14 テーマを変更する1 8.15 完成形 8.16 ggplot2による図の保存 8.17 他の描画レイヤー 8.18 練習問題: 折れ線グラフ 8.19 箱ひげ図 8.20 ヴァイオリンプロット 8.21 適した描画？ 8.22 ゼミ課題：データの描画", " Chapter 8 ビジュアライゼーションの基本 8.1 Rにおける描画 データを可視化するビジュアリゼーションは、プレゼンテーションだけではなく分析者自身がデータを理解するためにも有効で重要なテクニック。 Rにはデフォルトの描画関数も用意されているが、tidyverseシリーズのggplot2というパッケージの関数が強力であり昨今はスタンダードになっていることから、こちらを紹介する。 ggplot2とは、グラフィックの文法 (grammar of graphics)という概念に基づいて作図するパッケージ 8.2 準備 あらたにRスクリプトを作成し、data_viz.Rという名前をつけて保存する。 そして、以下のライブラリを読み込んでおく。ライブラリがなくてエラーが出る場合はインストールしてから再度読み込む。 library(tidyverse) 8.3 描画をしてみよう Ch.2の武蔵大学経済学部の学生数のデータを作ってみよう。 8.4 復習：データ読み込み まずデータをダウンロードする。 # dataフォルダを作成していない場合はdataフォルダ（ディレクトリ）の作成 fs::dir_create(&quot;data&quot;) # データのダウンロードとdataフォルダへの保存 download.file(&quot;https://github.com/keita43a/regression_tutorial/blob/main/docs/data/musashi_keizai_students_2023.xlsx?raw=TRUE&quot;, destfile=&quot;data/musashi_keizai_students_2023.xlsx&quot;) ダウンロードしたデータを読み込む。 # エクセルからデータを読み込み data_634 &lt;- readxl::read_excel(&quot;data/musashi_keizai_students_2023.xlsx&quot;) # long型(tidy data)に変換 data_634_long &lt;- data_634 |&gt; # long型に変換。1年〜４年の列(cols)を学生数という列にvalues_toでまとめる。各行に何年生かnames_toで記録する。 pivot_longer(cols=c(&quot;1年&quot;,&quot;2年&quot;,&quot;3年&quot;,&quot;4年&quot;),names_to =&quot;学年&quot;,values_to = &quot;学生数&quot;) 8.5 描画の前に データに少し工夫を加える データは文字列（カテゴリ）の順番を勝手に決めてしまう。 文字列をファクター型に変換する。 描画するときにカテゴリの順番を揃えたいので、順番の情報を与える。 8.6 キャンバスを用意する まずキャンバスを用意するイメージでggplot()関数を呼び出す plot_634 &lt;- ggplot() print(plot_634) 8.7 グラフのレイヤーを追加する グラフの種類ごとにデータを表現する幾何学的オブジェクトgeom_が用意されている geom_barは棒グラフで表現する。 引数として、用いるデータdata, x軸, y軸, 色などにデータを割り当てるmapping,そして、変数をどう扱うかというstatがある。 mappingにはaesという関数を使ってデータを当てはめる。 x軸は学年、y軸は学生数とする。 statにはデータそのものの数値を使うため、\"identity\"を指定する。 plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数),stat=&quot;identity&quot;) # &lt;- 追加！ print(plot_634) 8.8 文字化けに対処する Macを使っていると、ggplotで日本語を使うと文字化けすることが知られている 豆腐化現象と呼ばれている 文字化けに対処するため、日本語のフォントを指定する。 Windowsは多分不要。 新しくtheme_greyというレイヤーを作り、その中のbase_familyという引数でフォント名\"HiraKakuPro-W3\"を指定する。 plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数),stat=&quot;identity&quot;) + theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) # &lt;- 追加！ print(plot_634) 8.9 aesに色を追加する 男女別に表示したいので、男女を色で分けたい マッピングでaesの中に色の変数として性別を指定する。 色のマッピングには二種類あり、点・線・枠の色を指定するcolorと、面の色を指定するfillがある。 この場合は塗りつぶしたいので、fillを指定する。 色は指定しなければ自動的に決められる。 plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別),stat=&quot;identity&quot;)+ # &lt;- 追加！ theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) print(plot_634) 8.10 男女の置き方を変えたい 男女を縦に積むのではなく、横に置くことで対比がしやすくなりそう。 geom_bar()の引数のpositionをdodgeに指定する。 デフォルトはstackになっている（文字通り「積む」） plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別), # &lt;- 追加！ stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) print(plot_634) 8.11 色を変えたい 色は指定しなければ自動的に決まる わかりやすい、おしゃれな色を使いたい場合はマニュアルで変えられる scale_fill_manual()の中でvalueという色で変えることが可能。 複数指定する場合はc()の中に並べてベクトルとして扱う 色の順番に注意 簡単な色の名前(例：\"blue\", \"red\")でも指定できるし、RGB値でも決められる RGB値はネットで検索してみよう ここでは、武蔵大学のロゴの緑と黄色を使う。 plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別), stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ scale_fill_manual(values =c(&quot;#0A6648&quot;,&quot;#F6B21B&quot;)) + # &lt;- 追加！ theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) print(plot_634) 8.12 学科別に分けたい 現状では、学科の人数がすべて積算されてしまっているが、データとしては分かれている せっかくなので別で表示したいが、もうx軸もy軸も色も使ってしまっている。 では、グラフ自体を分けてしまおう facet_wrap()というレイヤーを使う ~の後に分割に使うカテゴリを指定することで、分割した図を作ってくれる plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別), stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ scale_fill_manual(values =c(&quot;#0A6648&quot;,&quot;#F6B21B&quot;)) + theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) + facet_wrap(~ 学科) # &lt;- 追加！ print(plot_634) 8.13 ラベルを変更する・タイトルを追加する 通常はラベルを明示する lab()レイヤーの中で、X軸ならx=, Y軸ならy=で変更する 色の凡例のタイトルもfill= 今回は学年は明らか、学生数もタイトルで明示するので空欄とする 空欄としたい場合は\"\" タイトルを追加する場合は、title= サブタイトルもsubtitle=で追加できる 右下のノートもcaption=で追加できる plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別), stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ scale_fill_manual(values =c(&quot;#0A6648&quot;,&quot;#F6B21B&quot;)) + labs(fill=&quot;&quot;,x=&quot;&quot;,y=&quot;&quot;, # &lt;- 追加! title=&quot;武蔵大学経済学部の学科別・男女別学生数&quot;, # &lt;- 追加! subtitle=&quot;2023年5月1日時点&quot;, # &lt;- 追加! caption = &quot;データ元：武蔵大学公式ウェブサイト&quot;) + # &lt;- 追加! theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) + facet_wrap(~ 学科) # &lt;- 追加！ plot_634 8.14 テーマを変更する1 テーマ (theme)はggplotの細かい見た目を設定する 背景、軸の有無、グリッドの数や濃さ、軸ラベルの字の大きさなどなど ggplotは背景がグレーのテーマがデフォルト themeレイヤーで細かい設定を行う theme_***でデフォルトテーマを使うこともできる ここでどんなテーマがあるか見られる 8.14.1 デフォルトテーマを使った変更 ここでは見た目をスッキリさせるデフォルトテーマtheme_minimalを使ってみる plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別), stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ scale_fill_manual(values =c(&quot;#0A6648&quot;,&quot;#F6B21B&quot;)) + labs(fill=&quot;&quot;,x=&quot;&quot;,y=&quot;&quot;, title=&quot;武蔵大学経済学部の学科別・男女別学生数&quot;, subtitle=&quot;2023年5月1日時点&quot;, caption = &quot;データ元：武蔵大学公式ウェブサイト&quot;) + theme_minimal(base_family=&quot;HiraKakuPro-W3&quot;) + # &lt;- 変更! facet_wrap(~ 学科) ## &lt;- 追加！ 8.14.2 細かいテーマ設定 細かいテーマ設定をthemeレイヤーの中で行う panel.grid.major.xはメインのグリッドの設定 element_blank()は、「空」にするという設定 legend.positionで、凡例を右ではなく下\"bottom\"に textで図の中の文字を設定 element_text()で設定する size=15としてフォントサイズを15にする。 plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=学年, y=学生数, fill=性別), stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ scale_fill_manual(values =c(&quot;#0A6648&quot;,&quot;#F6B21B&quot;)) + labs(fill=&quot;&quot;,x=&quot;&quot;,y=&quot;&quot;, title=&quot;武蔵大学経済学部の学科別・男女別学生数&quot;, subtitle=&quot;2023年5月1日時点&quot;, caption = &quot;データ元：武蔵大学公式ウェブサイト&quot;) + theme_minimal(base_family=&quot;HiraKakuPro-W3&quot;) + theme(panel.grid.major.x = element_blank(), # &lt;- 追加! legend.position = &quot;bottom&quot;, # &lt;- 追加! text = element_text(size=15)) + # &lt;- 追加! facet_wrap(~ 学科) 8.15 完成形 8.16 ggplot2による図の保存 ggplotで作図した結果をオブジェクトに保存 ここの例ではplot_634に保存 figという名前のフォルダを作っておく。 ggsaveという関数で、ファイルパスを指定して保存 fileという引数に、\"fig/musashi_students_2023.png\"と指定 figディレクトリの下にmusashi_students_2023という名前でpng形式ファイルとして保存するという意味 plotに保存したいggplotオブジェクト（描画したもの）を指定 deviceに保存したい画像形式を指定。ここではpngを指定している。他にはtiff,pdf,jpgなど。 # figフォルダ（ディレクトリ）の作成 fs::dir_create(&quot;fig&quot;) # ggsave()関数を使って、図を保存 # file: 保存する場所, plot: 図のオブジェクト, device: 保存する形式 ggsave(file=&quot;fig/musashi_students_2023.png&quot;, plot=plot_634, device=&quot;png&quot;) 8.17 他の描画レイヤー 関数 描画 geom_point 散布図 geom_line 折れ線グラフ geom_boxplot 箱ひげ図 geom_violin バイオリンプロット geom_map 地図を描く 他にも多くの描画レイヤーが存在する 参考 8.17.1 練習問題：散布図 ここではdiamondsというggplotに付属しているデータセットを使う。 このデータには、ダイヤモンドの一つ一つのクオリティとその価格が記録されている。クオリティはいやゆるダイヤモンドの4Cと言われるカラット(Carat), カット(Cut), 色(Color), 透明性(Clarity)で表されている。 ここでは、大きさであるカラットと価格の関係性、さらに色の影響を見てみる。 # diamondsというデータを読みこむ data(diamonds) # diamondsの変数を確認する names(diamonds) ## [1] &quot;carat&quot; &quot;cut&quot; &quot;color&quot; &quot;clarity&quot; &quot;depth&quot; &quot;table&quot; &quot;price&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; # diamondsのデータの冒頭を確認する head(diamonds) ## # A tibble: 6 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 課題：以下の画像を作成してみよう。 8.18 練習問題: 折れ線グラフ ここではeconomicsというggplotに付属しているデータセットを使う。 このデータには、アメリカの主要な経済指標が時系列データとして記録されている。dateは年月、popは人口(1000人)、psavertは個人貯蓄率、unempmedは失業期間の中央値（週）、unemployは失業数（1000人）である。 # economicsというデータを読みこむ data(economics) # diamondsの変数を確認する names(economics) ## [1] &quot;date&quot; &quot;pce&quot; &quot;pop&quot; &quot;psavert&quot; &quot;uempmed&quot; &quot;unemploy&quot; # diamondsのデータの冒頭を確認する head(economics) ## # A tibble: 6 × 6 ## date pce pop psavert uempmed unemploy ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1967-07-01 507. 198712 12.6 4.5 2944 ## 2 1967-08-01 510. 198911 12.6 4.7 2945 ## 3 1967-09-01 516. 199113 11.9 4.6 2958 ## 4 1967-10-01 512. 199311 12.9 4.9 3143 ## 5 1967-11-01 517. 199498 12.8 4.7 3066 ## 6 1967-12-01 525. 199657 11.8 4.8 3018 課題：アメリカの失業数の変遷の折れ線グラフを作成しよう。 8.19 箱ひげ図 geom_boxplotで箱ひげ図を描く 変数の分布を確認するのに有効 XとYの変数を指定する ここではmpgというggplotに付属しているデータセットを使う 車の種類をx軸, 各自動車の燃費をy軸 ] plot_boxplot &lt;- ggplot(data=mpg) + geom_boxplot(aes(x=class,y=hwy)) 8.20 ヴァイオリンプロット geom_violinでヴァイオリンプロットを描く 変数の分布を確認するのに有効 XとYの変数を指定する ここではmpgというggplotに付属しているデータセットを使う 車の種類をx軸, 各自動車の燃費をy軸 plot_violin &lt;- ggplot(data=mpg) + geom_violin(aes(x=class,y=hwy)) 8.21 適した描画？ 分析の目的やデータのタイプによって、用いたいグラフは異なる。どのような目的でデータ描画を行うのか考えてから描画に取りかかろう。 Figure 8.1: データタイプ別のグラフ 棒グラフ：データの大きさを比較する 折れ線グラフ：時系列での変化をみる 円グラフ：全体に占める割合をみる 積み上げ棒グラフ：累積データから内訳を比較する 散布図：2つのデータの相関関係をみる 例：グラフの種類と使い分け、間違った使い方(Tableau) 8.22 ゼミ課題：データの描画 データからグラフを描画し、それを英語で説明するプレゼンテーションを行う。 教育用標準データセットからデータを選ぶ。 選んだデータの中で、変数を選択する。 選択した変数について適切なグラフを描画する。 必要に応じてデータを加工する。 他人と同じ変数は使えないため、どのデータのどの変数を描画するかは早いもの勝ちである。 自分がどのデータセットのどの変数を描画するかをGoogle Classroomのストリームに投稿する。（締切：6/4 23:59） 描画した画像ファイルとRコードをGoogle Classroomの課題3-2に提出する。(締切：6/11 23:49） Rコードはkadai_presen_XXX.Rという名前をつけて保存する。XXXには自分の名前を英語で入れる。 描画した画像ファイルについて、2~3分のプレゼンテーションを行う（実施日：6/19 ゼミ） 英語で作成したグラフの説明を行う2~3分のプレゼンを準備する。 提出された画像からスライドを作るのでスライドは用意しなくて良い。 画像だけで自分で英語で説明する。どういうデータなのか、何を説明しているのか、グラフから何が言えそうか。 原稿やスマホを使ってはいけない。 順番はランダム。 8.22.1 例：SSDSE-B県別推移のデータ ここでは一例として、県別推移データの合計特殊出生率を示すデータ描画を作成する。 実際のデータ描画では、どのようなグラフ（棒グラフ・折れ線グラフなど）でも構わない。 あらたにRスクリプトを作成し、kadai_presen_XXX.Rという名前をつけて保存する。XXXには自分の名前を英語で入れる。 そして、以下のライブラリを読み込んでおく。 library(tidyverse) データをダウンロードして、dataフォルダに入れる。 データを読み込む。日本語のデータでエンコーディングがShift-JISなのでencodingを変更する必要がある（セクション6.2.2参照）。 ここではdataフォルダの下にSSDSEというフォルダを作って、そこにデータファイルを保存しているので、data/SSDSE/SSDSE-B-2024.csvをパスとして指定しているが、もしdataフォルダに直接保存している場合はdata/SSDSE-B-2024.csvとなる。 また、列名が2行にわたってしまっているので、最初の一行をskipするため、skip=1という引数を指定している。 data_ssdse &lt;- read_csv(&quot;data/SSDSE/SSDSE-B-2024.csv&quot;, locale=locale(encoding=&quot;CP932&quot;), skip=1) # 変数名を確認 names(data_ssdse) ## [1] &quot;年度&quot; &quot;地域コード&quot; &quot;都道府県&quot; ## [4] &quot;総人口&quot; &quot;総人口（男）&quot; &quot;総人口（女）&quot; ## [7] &quot;日本人人口&quot; &quot;日本人人口（男）&quot; &quot;日本人人口（女）&quot; ## [10] &quot;15歳未満人口&quot; &quot;15歳未満人口（男）&quot; &quot;15歳未満人口（女）&quot; ## [13] &quot;15〜64歳人口&quot; &quot;15〜64歳人口（男）&quot; &quot;15〜64歳人口（女）&quot; ## [16] &quot;65歳以上人口&quot; &quot;65歳以上人口（男）&quot; &quot;65歳以上人口（女）&quot; ## [19] &quot;出生数&quot; &quot;出生数（男）&quot; &quot;出生数（女）&quot; ## [22] &quot;合計特殊出生率&quot; &quot;死亡数&quot; &quot;死亡数（男）&quot; ## [25] &quot;死亡数（女）&quot; &quot;転入者数（日本人移動者）&quot; &quot;転入者数（日本人移動者）（男）&quot; ## [28] &quot;転入者数（日本人移動者）（女）&quot; &quot;転出者数（日本人移動者）&quot; &quot;転出者数（日本人移動者）（男）&quot; ## [31] &quot;転出者数（日本人移動者）（女）&quot; &quot;婚姻件数&quot; &quot;離婚件数&quot; ## [34] &quot;年平均気温&quot; &quot;最高気温（日最高気温の月平均の最高値）&quot; &quot;最低気温（日最低気温の月平均の最低値）&quot; ## [37] &quot;降水日数（年間）&quot; &quot;降水量（年間）&quot; &quot;着工建築物数&quot; ## [40] &quot;着工建築物床面積&quot; &quot;旅館営業施設数（ホテルを含む）&quot; &quot;旅館営業施設客室数（ホテルを含む）&quot; ## [43] &quot;標準価格（平均価格）（住宅地）&quot; &quot;標準価格（平均価格）（商業地）&quot; &quot;幼稚園数&quot; ## [46] &quot;幼稚園教員数&quot; &quot;幼稚園在園者数&quot; &quot;小学校数&quot; ## [49] &quot;小学校教員数&quot; &quot;小学校児童数&quot; &quot;中学校数&quot; ## [52] &quot;中学校教員数&quot; &quot;中学校生徒数&quot; &quot;中学校卒業者数&quot; ## [55] &quot;中学校卒業者のうち進学者数&quot; &quot;高等学校数&quot; &quot;高等学校教員数&quot; ## [58] &quot;高等学校生徒数&quot; &quot;高等学校卒業者数&quot; &quot;高等学校卒業者のうち進学者数&quot; ## [61] &quot;短期大学数&quot; &quot;大学数&quot; &quot;短期大学教員数&quot; ## [64] &quot;大学教員数&quot; &quot;短期大学学生数&quot; &quot;大学学生数&quot; ## [67] &quot;短期大学卒業者数&quot; &quot;短期大学卒業者のうち進学者数&quot; &quot;大学卒業者数&quot; ## [70] &quot;大学卒業者のうち進学者数&quot; &quot;専修学校数&quot; &quot;各種学校数&quot; ## [73] &quot;専修学校生徒数&quot; &quot;各種学校生徒数&quot; &quot;新規求職申込件数（一般）&quot; ## [76] &quot;月間有効求職者数（一般）&quot; &quot;月間有効求人数（一般）&quot; &quot;充足数（一般）&quot; ## [79] &quot;就職件数（一般）&quot; &quot;一般旅券発行件数&quot; &quot;延べ宿泊者数&quot; ## [82] &quot;外国人延べ宿泊者数&quot; &quot;着工新設住宅戸数&quot; &quot;着工新設持家数&quot; ## [85] &quot;着工新設貸家数&quot; &quot;着工新設分譲住宅数&quot; &quot;着工新設住宅床面積&quot; ## [88] &quot;着工新設持家床面積&quot; &quot;着工新設分譲住宅床面積&quot; &quot;着工新設貸家床面積&quot; ## [91] &quot;ごみ総排出量（総量）&quot; &quot;1人1日当たりの排出量&quot; &quot;ごみのリサイクル率&quot; ## [94] &quot;一般病院数&quot; &quot;一般診療所数&quot; &quot;歯科診療所数&quot; ## [97] &quot;保育所等数&quot; &quot;保育所等定員数&quot; &quot;保育所等利用待機児童数&quot; ## [100] &quot;保育所等在所児数&quot; &quot;保育所等保育士数&quot; &quot;消費支出（二人以上の世帯）&quot; ## [103] &quot;食料費（二人以上の世帯）&quot; &quot;住居費（二人以上の世帯）&quot; &quot;光熱・水道費（二人以上の世帯）&quot; ## [106] &quot;家具・家事用品費（二人以上の世帯）&quot; &quot;被服及び履物費（二人以上の世帯）&quot; &quot;保健医療費（二人以上の世帯）&quot; ## [109] &quot;交通・通信費（二人以上の世帯）&quot; &quot;教育費（二人以上の世帯）&quot; &quot;教養娯楽費（二人以上の世帯）&quot; ## [112] &quot;その他の消費支出（二人以上の世帯）&quot; データの加工: 都道府県別の合計特殊出生率の推移を比較する。しかし、すべての都道府県では多すぎるため、関東の１都６県に限定する。 data_kanto &lt;- data_ssdse |&gt; filter(都道府県 %in% c(&quot;東京都&quot;,&quot;神奈川県&quot;,&quot;千葉県&quot;,&quot;埼玉県&quot;,&quot;茨城県&quot;,&quot;栃木県&quot;,&quot;群馬県&quot;)) # %in% は 「都道府県というカテゴリ変数が、c()の中のいずれかに該当すれば真、という命題を表す。 グラフ描画する plot_f_rate &lt;- ggplot(data=data_kanto,aes(x=年度, y=合計特殊出生率, col=都道府県)) + geom_line() + geom_point() + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) plot_f_rate ５．英語で発表するため、英語に変換する plot_f_rate &lt;- ggplot(data=data_kanto,aes(x=年度, y=合計特殊出生率, col=都道府県)) + geom_line() + geom_point() + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) + # ラベルを変換 labs(x=&quot;Fiscal Year&quot;, y=&quot;Total Fertility Rate&quot;, col=&quot;Pref.&quot;) + # カテゴリの名前（都道府県を変換） scale_color_discrete(breaks = c(&quot;千葉県&quot;,&quot;埼玉県&quot;,&quot;東京都&quot;,&quot;栃木県&quot;,&quot;神奈川県&quot;,&quot;群馬県&quot;,&quot;茨城県&quot;), labels = c(&quot;Chiba&quot;,&quot;Saitama&quot;,&quot;Tokyo&quot;,&quot;Tochigi&quot;,&quot;Kanagawa&quot;,&quot;Gumma&quot;,&quot;Ibaragi&quot;)) + theme(text = element_text(size=15)) # スライドで見やすくするために字を大きくする plot_f_rate 保存する。ここではpng形式で保存している。保存するファイルのパスの最後（ファイル名）に.pngを指定し、deviceという引数にpngを指定している。 保存したファイルはパワーポイントなどに貼ることができる。 ggsave(&quot;fig/fertility_rate_by_pref_2010_2021.png&quot;,plot_f_rate, device=&quot;png&quot;) "],["rstatsinfe.html", "Chapter 9 推測統計のおさらい 9.1 母集団と標本 9.2 推定量 9.3 母平均の信頼区間 9.4 統計的仮説検定", " Chapter 9 推測統計のおさらい 9.1 母集団と標本 7.1.2で説明したように、各自が興味を持つ研究対象について、全体を知ることは難しくても一部を知ることで全体を推し量ることができる。この研究対象の全体を母集団と呼ぶ。例えば、「日本の漁業者の収入は一般の収入より高いか？」という問題に取り組むとしても、日本の漁業者全員分の収入を集めることは難しいし、一般の人の収入ならなおさらである。そこで、一部をサンプリングしてサンプル（標本）による調査を行う。このサンプルの大きさをサンプルサイズ(標本サイズ)と呼ぶ。 言葉の誤用に注意 よくある統計学関係の言葉で、誤用されることが多いものを挙げておく。 まず、母集団とよく間違えられるのが母数である。「母数が多いから…」などとしてよく使われるが、母数とは実はパラメータのことを表す。パラメータとは母集団の特徴を表す係数のことを指す。例えば、内閣支持率が40%である、などという報道を聞くことがある。これはもし１億人有権者がいるとして、その全員に聞いた結果4000万人が支持しているとするならば、この「本当の支持率」は母数の一つである母比率である。しかし、実際には全員に聞くことは難しい。報道なのでは1000人程度に電話で聞いた結果を、内閣支持率として発表するが、これは母比率を推定しているのである。母数は一般的に我々にとっては未知であり、だからこそサンプリングしたデータで推定するのである。  また、サンプルの大きさという意味でよく誤用されるのがサンプル数である。サンプル数とは、標本の数がいくつかあるか（標本のグループがいくつあるか）を表すため、サンプルの大きさという意味で使うのは間違いである。   ## サンプリング 母集団からサンプルを選ぶことをサンプリング（標本抽出）と呼ぶ。このサンプリングが適切でないと、母集団の特徴を適切に推定することはできない。例えば、日本人の平均身長を調査しようと思って、小学校ばかり回って計測していっても日本人全体を推定できると言えないことはわかるだろう。  サンプルを偏りなく選ぶ代表的な方法は単純無作為抽出もしくはシンプルランダムサンプリング(Simple random sampling)と呼ばれる。これは、母集団のうちどの個体も選ばれる確率が等しくなるように選ぶという意味である。その他には系統抽出法, 多段抽出法, 層化抽出法などがあるが、説明は省略する。興味がある学生はたとえば東京大学教養学部統計学教室編「人文・社会科学の統計学」（東京大学出版会）などを参照してほしい。 9.2 推定量 母数の推定に利用されるもの推定量という。例えば、日本人の平均身長が\\(\\mu\\)cmであるとする（\\(\\mu\\)はミューと読むギリシャ文字である）。この「本当の」平均身長は日本人全員の身長を測って平均を取ったものであり、母数の一つである母平均である。しかし、この母平均を実際に計測・計算するのは難しい。そこで、サンプリングを行って1000人を日本人全員の中から抜き出して、サンプルとして計測し、平均を計算する。このとき、計算した平均\\(\\bar{x}\\)cmは標本平均と呼ばれる。例えば\\(\\bar{x}=170\\)とすると、日本人の本当の平均身長は170cmかもしれないし、実は169cmかもしれない。でも185cmである可能性は低そうである。ドンピシャで当てられるかはわからないが、おそらく可能性が高い数値として推定量として用いられるのである。ここでは、標本平均という統計量は、母平均のよい推定量であるという。 9.2.1 不偏性 上では標本平均は母平均のよい推定量と書いたが、よい推定量とはなんだろうか？推定量としてよいかどうかにはいくつかの基準がある。 まずひとつ目は不偏性 (unbiasedness)である。これは、もし仮に何度もサンプリングを行って標本平均をたくさんとったとき（例えば1000回サンプリングを繰り返して、1000個の標本平均が計算できたとき）、その標本平均の平均は、母平均と等しいという性質である。一回のサンプリングによる標本の標本平均は、実際には母平均とはズレがある可能性は否定できない。しかし、その推定プロセスでは、平均的に正しい（母平均と等しい）値が得られるという性質を持つ推定量は不偏性を持つといい、不偏推定量と呼ばれる。 これをRにおけるシミュレーションで確認してみよう。 set.seed(20240509) # ランダムなプロセスを再現するためにseedを設定する。 # 母集団を決める（シミュレーションなので現実とは異なる） mu = 170 sigma = 10 # サンプルサイズを決める。今回は100人だとする。 sample_size = 100 # rnorm(n,mean,sd)は、meanとsdという母数を持つ正規分布という確率分布を持つ母集団から、n個（今回はn人）をランダムにサンプリングするという関数である。 sample1 &lt;- rnorm(n=sample_size, mean = mu, sd = sigma) # 平均を計算する sample1_mean &lt;- mean(sample1) sample1_mean ## [1] 171.1845 まず、一度だけのサンプリングと標本平均の計算を行った。 この結果、標本平均は171.18cmなので、母平均の170cmにまぁ近い。 では、このコードを編集して、for関数を用いたループで1000回サンプリングしてみよう。for関数についてはセクション4.2.2を参照。 set.seed(20240509) # ランダムなプロセスを再現するためにseedを設定する。 # 母集団を決める（シミュレーションなので現実とは異なる） mu = 170 sigma = 10 # サンプルサイズを決める。今回は1000人だとする。 sample_size = 100 # 標本平均を格納するベクトルをつくっておく sample_mean &lt;- vector() # 繰り返しloop for(i in 1:1000){ # iという変数を1から1000まで繰り返す # サンプリングを行って、sample1というオブジェクトに格納する sample1 &lt;- rnorm(n=sample_size, mean = mu, sd = sigma) # 平均を計算して、それをsample_meanのi番目の要素に格納する sample_mean[i] &lt;- mean(sample1) } # 繰り返しが終わったら、sample_meanの平均を獲る mean(sample_mean) ## [1] 169.9808 標本平均の平均を見てみると、限りなく170cmに近い数値が出ている。 しかし、一回一回の標本平均がピッタリ170cmであるわけではない。1000回とった標本平均がどのような散らばりを持っているのか、ヒストグラムを描いてみよう。 # ヒストグラムを描画してみる # ggplot2はデータフレームかtibbleしか受け付けないので、tibbleに変換する。sample_meanという変数にする data_sample_mean = tibble(sample_mean = sample_mean) # ggplotのgeom_histogramで描画する。見やすいように枠線を青に、中身をグレーに変更している。 ggplot(data = data_sample_mean) + geom_histogram(aes(x = sample_mean), col=&quot;blue&quot;,fill=&quot;gray&quot;) 標本平均一つ一つであれば、小さいもので167cmぐらい、大きいものだと173cmぐらいまでズレがあることがわかる。それぞれ170cmピッタリとは限らないが、平均的には170cmを推定できていることがわかる。 このことから、標本平均が母平均を推定する推定量として、不偏性を持っているということがわかる。 9.2.2 一致性 9.3 母平均の信頼区間 9.3.1 標準誤差 9.3.2 信頼区間 9.4 統計的仮説検定 9.4.1 仮説設定 9.4.2 有意水準 9.4.3 棄却域 "],["correlation.html", "Chapter 10 相関関係 10.1 ２つの変数の関係 10.2 相関関係と因果関係 10.3 順位相関係数", " Chapter 10 相関関係 10.1 ２つの変数の関係 実証分析において重要な問いとして「XがYに影響を与えるか」というものである。 例えば、最低賃金を上げると雇用率に影響を与えるか？生徒教員比を減らすと生徒のテストのパフォーマンスはよくなるか？などである。 Xが政策的に変更できる変数であり、Yがなにか経済・社会的に重要な変数ならば、Xを増やす/減らすことでYに影響を与えられる、という政策含意が得られる。 まずは、そもそも2つの変数に統計的な関係があるかを見ていこう。 10.1.1 共分散 共分散は直接解釈するとXの偏差とYの偏差の積の平均、となる。 例えば、次のような5人の国語と算数の試験の点数のデータがあるとする。 ## student kokugo sugaku ## 1 A 50 52 ## 2 B 50 75 ## 3 C 80 62 ## 4 D 70 89 ## 5 E 90 99 それぞれの平均を求めてみよう。 test |&gt; summarise(kokugo_average = mean(kokugo), sugaku_average = mean(sugaku)) ## kokugo_average sugaku_average ## 1 68 75.4 それぞれ国語が68点、算数が75.4点という結果である。 Aさんはそれぞれの科目で、平均からどれぐらい離れているか？言い換えると、偏差はいくつだろうか。 \\[ 国語の偏差 = 50-68 = -18\\\\ 数学の偏差 = 52-75.4 = -23.4 \\] となる。 偏差の積とは、\\(-18\\times-23.4\\)なので\\(421.2\\)になる。 5人の偏差とその積をとってみよう。 test |&gt; mutate(kokugo_hensa = kokugo - mean(kokugo), sugaku_hensa = sugaku - mean(sugaku)) |&gt; mutate(hensa_seki = kokugo_hensa*sugaku_hensa) ## student kokugo sugaku kokugo_hensa sugaku_hensa hensa_seki ## 1 A 50 52 -18 -23.4 421.2 ## 2 B 50 75 -18 -0.4 7.2 ## 3 C 80 62 12 -13.4 -160.8 ## 4 D 70 89 2 13.6 27.2 ## 5 E 90 99 22 23.6 519.2 ここで、あることに気づいた人もいるかもしれない。 偏差の積は、どちらもよいかどちらも悪い点数なら、正の数で大きくなり、どちらかが悪くてもう一つがよいと、負の数になる。 このケースで言えば、Aさん（どちらも悪い）や、Eさん（どちらもよい）は、偏差の積が正で大きく、Cさん（国語は良いが数学は悪い）は、偏差の積が負になっている。 この平均を取るということは、どちらも悪い・どちらも良い、という傾向があるか、どちらかが悪いともう片方がよい、という傾向があるかということがわかるということである。 偏差の積の平均を取ってみよう。 test |&gt; mutate(kokugo_hensa = kokugo - mean(kokugo), sugaku_hensa = sugaku - mean(sugaku)) |&gt; mutate(hensa_seki = kokugo_hensa*sugaku_hensa) |&gt; summarise(hensa_seki_average = mean(hensa_seki)) ## hensa_seki_average ## 1 162.8 ここでは、162.8という正の数となった。 この数字（2つの変数の偏差の積の平均）を共分散と呼び、2つの変数の関係性を測る指標となる。 一般に共分散が正であれば、正の関係がある（Xが大きいときYも大きい傾向がある）、負であれば負の関係がある（Xが大きいとき、Yが小さい傾向がある）。 上の例では、国語の成績がいい人は数学の成績がいい傾向がある、ということになる。 共分散の定義は、以下のような式で定義できる。 \\[\\sigma_{xy} = \\frac{1}{n}\\sum^{n}_{i=1}(x_i - \\bar{x})(y_i - \\bar{y})\\] Rでは、cov()という関数が用意されているが、不偏共分散を推定する関数である。そのため、サンプルサイズが小さい上のようなケースでは、\\(n\\)で割った場合と大きく異なる数字が出る。 test |&gt; summarise(kyoubunsan = cov(kokugo, sugaku)) ## kyoubunsan ## 1 203.5 10.1.2 相関係数 共分散は2つの変数の関係を見る指標になると述べたが、実際にはあまり使われない。 その理由は、共分散は単位に依存するからである。 例えば、身長と体重のデータがあるとして、身長とmで測るのか、cmで測るのかで共分散は大きく異なる。 しかし、そもそものデータで標準化すれば、単位の問題はなくなる。 先に定義を提示すると、以下のようになる。 \\[ \\rho_{xy} = \\frac{\\sigma_{xy}}{\\sigma_x \\sigma_y} \\] 言葉で説明すれば、相関係数とは共分散をXとYのそれぞれの標準偏差で割った数字である。 単位が大きければばらつきも大きくなるわけなので、そのばらつき自体で割ってしまえば単位に依存しない偏差を計算できるというわけである。 上のテストデータで計算してみよう。 test |&gt; mutate(kokugo_hensa = kokugo - mean(kokugo), sugaku_hensa = sugaku - mean(sugaku)) |&gt; mutate(hensa_seki = kokugo_hensa*sugaku_hensa) |&gt; summarise(hensa_seki_average = mean(hensa_seki), kokugo_sd = sd(kokugo), sugaku_sd = sd(sugaku), soukan_keisu = hensa_seki_average/(kokugo_sd*sugaku_sd)) ## hensa_seki_average kokugo_sd sugaku_sd soukan_keisu ## 1 162.8 17.88854 19.16507 0.4748637 相関係数は相関の程度を表す係数であり、\\(-1\\)から\\(1\\)までの実数を取る。数字が負であれば、負の関係があり、正であれば正の関係がある。絶対値が1に近いほど、その関係が強いことを表している。 相関係数を計算する関数には、corが用意されている。こちらも、共分散を計算する際にn-1で割るため、サンプルサイズが小さい場合はnで割った場合と大きく異なる数字が出る。 cor(test$kokugo,test$sugaku) ## [1] 0.5935796 10.1.3 散布図 相関関係を図で描くと直感的である。 例えば、正の相関関係は以下のような図となる。 また、負の相関関係がある場合は以下のような形である。 上の図の観察をまとめると、 正の場合は右肩上がり、負の場合は右肩下がりの傾向がある 相関関係が強い(相関係数の絶対値が１に近い)ほどばらつきが少ない 10.2 相関関係と因果関係 ここまでは２つの変数の関係として、相関関係を議論してきた。 しかし、社会科学の実証分析で重要な点として、相関関係は必ずしも因果関係を意味しないということがある。 たとえば、下の図はある年の日ごとのアイスクリームの売上と水難事故の件数だとする。 このことから、アイスクリームの売上と水難事故件数には相関関係がありそうだ。実際に計算してみても、相関係数は0.63と計算された。 しかし、この２つの間に因果関係はあるだろうか？ 例えば、アイスクリームの売上を増やすと水難事故も増えるのだろうか？ では、政策的含意として、アイスクリームの販売に規制をかけて売上を増やさないようにすることで、水難事故を防ぐことはできるのだろうか？ もちろんできない。 この２つの変数の後ろには気温という別の変数が隠れている。 気温が高ければ、人々はアイスクリームを買って食べるし、川や海にレジャーに行くため水難事故の絶対数も増えてしまう。 しかし、アイスクリームと水難事故には直接の関係はないのである。 このような相関関係を見せかけの相関と呼ぶ。 3つの変数の相関係数をそれぞれ計算してみよう。 # dayを計算に入れたくないので、除く dat_ice2 = dat_ice |&gt; dplyr::select(-day) cor(dat_ice2) ## temp ice accident ## temp 1.0000000 0.9293655 0.6948090 ## ice 0.9293655 1.0000000 0.6334513 ## accident 0.6948090 0.6334513 1.0000000 ここではdayは実際には変数ではないので無視する。 気温(temp)とアイスクリームの売上(ice)は0.93と非常に強い相関関係がある。 気温(temp)と水難事故(accident)も0.69とある程度強い相関関係になっている。 アイスクリームの売上と水難事故も0.63と強い相関関係があるが、果たしてその相関関係はどちらかがどちらかに直接影響を与えるような関係なのだろうか？ 10.2.1 偏相関係数 見かけ上の相関が疑われ、その間にある第3の変数がわかっている場合は、偏相関係数を用いることで相関を測ることができる。 第3の変数を\\(z\\)とすると、 \\[ \\rho_{xy,z} = \\frac{\\rho_{xy}-\\rho_{xz}\\rho_{zy}}{\\sqrt{1-\\rho_{xz}^2}\\sqrt{1-\\rho_{yz}^2}} \\] で表される。 上の場合では、気温という第3の変数の影響を除いた後のアイスクリームの売上と水難事故の相関係数に当たる。 10.2.1.1 Rによる偏相関係数の推定 Rで偏相関係数を計算する場合は、ppcorパッケージのpcor関数を使う。 # パッケージのインストール install.packages(&quot;ppcor&quot;) # パッケージの読み込み library(ppcor) # 偏相関係数の計算 pcor_ice &lt;- pcor(dat_ice2) pcor_ice$estimate ## temp ice accident ## temp 1.0000000 0.8791336 0.3714375 ## ice 0.8791336 1.0000000 -0.0462535 ## accident 0.3714375 -0.0462535 1.0000000 偏相関係数の結果を見てみると、気温(temp)とアイスクリームの売上(ice)は0.88と、水難事故の影響を除いても非常に強い相関関係がある。 気温(temp)と水難事故(accident)も0.37と、ある程度の正の相関関係が残っている。 アイスクリームの売上と水難事故は、気温の影響を除くと-0.05とほとんどゼロに近い相関係数であり、気温を通した関係以外はないことがわかる。 10.3 順位相関係数 上の相関係数は、一般に積率相関係数と呼ばれていて、量的な変数に用いられる。 しかし、質的な基準（例えばランキング）の場合は直接積率相関係数を適用することができない。 例：男性と女性にそれぞれどの花が好きかというアンケート調査をした結果、以下のような順位になったとする。女性と男性の傾向に相関関係はあるのだろうか？ 花 男 女 桜 1 3 菊 2 1 バラ 3 2 梅 4 5 ゆり 5 4 チューリップ 6 7 カーネーション 7 6 椿 8 8 図で描くと以下のような形になる。 # データ準備 dat_flower = tibble( flower = c(&quot;桜&quot;,&quot;菊&quot;,&quot;バラ&quot;,&quot;梅&quot;,&quot;ユリ&quot;,&quot;チューリップ&quot;,&quot;カーネーション&quot;,&quot;椿&quot;), male = c(1,2,3,4,5,6,7,8), female = c(3,1,2,5,4,7,6,8)) |&gt; mutate(flower = fct_reorder(flower,male)) # 整然データ化 dat_flower_long = dat_flower |&gt; pivot_longer(cols=ends_with(&quot;male&quot;), names_to = &quot;gender&quot;,values_to=&quot;rank_flower&quot;) データを”散布図”で描いてみよう。 ggplot(dat_flower,aes(x=male,y=female)) + geom_point(size=4) + geom_text_repel(aes(label=flower), family=&quot;HiraKakuPro-W3&quot;) + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) + scale_x_continuous(breaks = 1:8) + scale_y_continuous(breaks = 1:8) + labs(y=&quot;女性の順位&quot;, x=&quot;男性の順位&quot;) + theme(panel.grid.minor = element_blank()) 図で描いてみると、なんとなく似た傾向があるように見えるが、これをどう定量的に表すのか？ もし、男女の順位が完全に一致していると、以下のような図になる。 flower male female 桜 1 1 菊 2 2 バラ 3 3 梅 4 4 ユリ 5 5 チューリップ 6 6 カーネーション 7 7 椿 8 8 このときは正の相関があることがわかるだろう。 全く男女の順位が逆であったらどうだろうか。 flower male female 桜 1 8 菊 2 7 バラ 3 6 梅 4 5 ユリ 5 4 チューリップ 6 3 カーネーション 7 2 椿 8 1 男女の順位に関係がなければどんな散布図になるだろうか。 flower male female 桜 1 6 菊 2 2 バラ 3 4 梅 4 8 ユリ 5 1 チューリップ 6 3 カーネーション 7 5 椿 8 7 ばらばらで男女の順位に関係がなさそうなことは直感的にはわかる。 これをどう定量的に表せばいいのだろうか？ 10.3.1 スピアマンの順位相関係数 相関係数でよく使われるものには二種類ある。一つはスピアマン(Spearman)の順位相関係数、もう一つはケンドール(Kendall)の順位相関係数である。 スピアマンの順位相関係数では、2つの系列の順位の差を二乗したものを計算する。 \\[ r_{s} = 1-\\frac{6}{n^3-n}\\sum^{n}_{i=1}(R_i - R_{i}&#39;)^2 \\] このスピアマンの順位相関係数では、数値が１に近いほど相関が強く、-1になるほど離れるほど逆の相関がある。 オリジナルデータのそれぞれの順位差 dat_flower |&gt; mutate(順位差=male-female, 順位差２乗=順位差^2) |&gt; knitr::kable() flower male female 順位差 順位差２乗 桜 1 3 -2 4 菊 2 1 1 1 バラ 3 2 1 1 梅 4 5 -1 1 ユリ 5 4 1 1 チューリップ 6 7 -1 1 カーネーション 7 6 1 1 椿 8 8 0 0 もし、完全に一致する順位ならば、\\(\\sum^{n}_{i=1}(R_i - R_{i}&#39;)^2\\)に部分は０になる。一方で、もし真逆の順位ならば、その部分はとても大きくなる。 完全に順位が一致するケースのそれぞれの順位差 dat_flower2 |&gt; mutate(順位差=male-female, 順位差２乗=順位差^2) |&gt; knitr::kable() flower male female 順位差 順位差２乗 桜 1 1 0 0 菊 2 2 0 0 バラ 3 3 0 0 梅 4 4 0 0 ユリ 5 5 0 0 チューリップ 6 6 0 0 カーネーション 7 7 0 0 椿 8 8 0 0 順位が真逆のケースのそれぞれの順位差 dat_flower3 |&gt; mutate(順位差=male-female, 順位差２乗=順位差^2) |&gt; knitr::kable() flower male female 順位差 順位差２乗 桜 1 8 -7 49 菊 2 7 -5 25 バラ 3 6 -3 9 梅 4 5 -1 1 ユリ 5 4 1 1 チューリップ 6 3 3 9 カーネーション 7 2 5 25 椿 8 1 7 49 順位がばらばらのケースのそれぞれの順位差 dat_flower4 |&gt; mutate(順位差=male-female, 順位差２乗=順位差^2) |&gt; knitr::kable() flower male female 順位差 順位差２乗 桜 1 6 -5 25 菊 2 2 0 0 バラ 3 4 -1 1 梅 4 8 -4 16 ユリ 5 1 4 16 チューリップ 6 3 3 9 カーネーション 7 5 2 4 椿 8 7 1 1 10.3.1.1 Rでのスピアマン相関係数の計算 Rではcor関数のmethod引数を変更するとスピアマンの相関係数が使える。 cor(dat_flower$male, dat_flower$female, method=&quot;spearman&quot;) ## [1] 0.8809524 上の他のケースを計算すると、完全一致のケースでは1, 真逆のケースでは-1, ばらばらのケースでは0.14となる。 10.3.2 ケンドールの順位相関係数 もう一つの順位相関係数であるケンドールの順位相関係数は、データの中の順位の相対的な違いに注目する。 もしデータは正順である場合は、そのペアに1を与える。正順であるとは\\(i\\)と\\(j\\)という項目について、ある系列では順位が\\(R_i &gt; R_j\\)である場合にもう一つの系列でも\\(R_i&#39; &gt; R_j&#39;\\)であることをいう。 これは\\((R_i-R_j)(R_i&#39;-R_j&#39;)&gt;0\\)とも表現できる。 データが逆順であるる場合は、そのペアに-1を与える。逆であるとはある系列では順位が\\(R_i &gt; R_j\\)である場合にもう一つの系列でも\\(R_i&#39; &lt; R_j&#39;\\)であることをいう。これは\\((R_i-R_j)(R_i&#39;-R_j&#39;)&lt;0\\)とも表現できる。 花のデータで言えば、男性の順位では桜（1位）は菊（2位）より順位が上（数字が小さい）ので\\(R_桜 &lt; R_菊\\)であるが、女性の順位では桜（3位）は菊（1位）より下（数字が大きい）であるため、\\(R_桜&#39; &gt; R_菊&#39;\\)となるため、桜と菊のペアには-1が与えられる。 ケンドールの順位相関係数では、すべてのペアに1か-1を与えて、1のペアの数と-1のペアの数をそれぞれ集計する。その差を取って、ペアの数で割った数である。 1のペアの数が\\(G\\), -1のペアの数が\\(H\\)だとすると、 \\[ \\tau = \\frac{G-H}{n(n-1)/2} \\] と定義される。 この値も、完全に順位が一致していれば、+1, 完全に逆ならば-1を取る。 ちなみに、この相関係数は元のデータが順位でなくても計算する事が可能である。なぜなら、ペアに対して与えるのは大小なので、数値そのものを使ったとしても、\\(x_i &gt; x_j\\)と\\(y_i &gt; y_j\\)ならば正順、というように各ペアに+1か-1を割り当てることが可能だからである。 10.3.2.1 計算例 実際にケンドールの相関係数を手計算で行うことで理解してみよう。 手計算で行うために、縮小版として4つの花で聞いたとするデータを使う。 dat_flower5 = tibble( flower = c(&quot;桜&quot;,&quot;菊&quot;,&quot;梅&quot;,&quot;椿&quot;), male = c(1,2,3,4), female = c(2,1,4,3)) |&gt; mutate(flower = fct_reorder(flower,male)) knitr::kable(dat_flower5) flower male female 桜 1 2 菊 2 1 梅 3 4 椿 4 3 ４つの花で聞いた男女の順位は上のようだとする。 この場合のケンドールの相関係数はすべてのペアについ男女２つの系列において順位を評価して、ペアを評価する。 具体的には以下のように計算する。 ペア 男性順位の比較 女性順位の比較 ペア評価 桜と菊 1 &lt; 2 2 &gt; 1 逆順 桜と梅 1 &lt; 3 2 &lt; 4 正順 桜と椿 1 &lt; 4 2 &lt; 3 正順 菊と梅 2 &lt; 3 1 &lt; 4 正順 桜と椿 2 &lt; 4 1 &lt; 3 正順 梅と椿 3 &lt; 4 4 &gt; 3 逆順 正順(+1)が4つなので\\(G=4\\)で、逆順(-1)が2つなので\\(H=2\\)である。 ペアの数は\\(4(4-1)/2 = 6\\)である。 これをあてはめると \\[ \\tau = \\frac{4-2}{6} = 1/3 \\simeq 0.33 \\] この場合は、弱いが正の相関があるといえる。 10.3.2.2 Rでのケンドール相関係数の計算 こちらも、cor関数の引数を変えることで、Rで計算が可能である。 cor(dat_flower$male, dat_flower$female, method=&quot;kendall&quot;) ## [1] 0.7142857 上の他のケースを計算すると、完全一致のケースでは1, 真逆のケースでは-1, ばらばらのケースでは0.14となる。 "],["simpleregression.html", "Chapter 11 単回帰分析 11.1 回帰分析 11.2 回帰分析の推定方法 11.3 演習問題：単回帰分析", " Chapter 11 単回帰分析 11.1 回帰分析 回帰分析は、２つ以上の変数があるときに、ある変数Yのばらつきが他の変数によって説明できる関係を定量的に示す式を求めることを目的としている。 経済学の実証分析では、回帰分析を用いて因果関係を明らかにしようとすることを目的としている。 しかし、注意しなればいけないのは、ただデータを回帰分析して推定しただけで出てきた結果が必ずしも因果関係とは限らないということである。 まず回帰分析を理解するために、単回帰分析から勉強しよう。 単回帰分析とは、説明する側の変数の数が一つである場合の回帰分析である。ここでは２つの変数XとYを考える。 回帰分析では、説明される側の変数Yを目的変数, 被説明変数, 従属変数などと呼ぶ。 説明する側の変数Xを説明変数、独立変数などと呼ぶ。ここではYを目的変数、Xを説明変数と呼ぶように統一する。 回帰分析はXとYの定量的な関係の構造を求めようとすることである。この構造のことをモデルと呼ぶ。 このモデルは、様々な関係が考えられる。これから説明するモデルは線形回帰と呼ばれ、直線的な関係があることを前提として推定するが、当然ながら非線形的（Xが増えると、最初はYも増えるが徐々にYが減少するようになる、など）な関係も存在しうる。そういった藻で右派非線形回帰と呼ばれる。 もっともシンプルな線形回帰の式が、以下の一次方程式で表される関係である。 \\[ Y = \\alpha + \\beta X \\] ここで、\\(\\alpha\\)と\\(\\beta\\)は回帰係数(regression coefficient)または単に係数と呼ばれる。 YとXの間に、このような線形的な関係があるだろう、という前提で具体的にどのような定量的な関係があるかを推定するのが回帰分析である。 たとえば、上の例で気温とアイスクリームの売上を考えてみる。 気温を\\(X\\), アイスクリームの売上を\\(Y\\)と考えると以下のような関係があると考える。 \\[ Y = \\alpha + \\beta X \\] ここでは、一般的に気温とアイスクリームの関係は、上の式で説明できると考えるのである。つまり、母集団における関係は上の式で表せられると考える。 しかし、当然ながら、上の式だけでは現実とは一致しない。大まかには、気温が上がればアイスクリームの売上が上がるが、上の式では例えば30度の日の売上はいつもおなじになる。しかし、現実には同じ気温での他の観察されない変数の影響や何らかのランダムな要素で上がり下がりがあるはずである。 そのような要素をすべてランダムな要素として、確率的な事象として扱ってしまう。すると、以下の式が得られる。 \\[ Y = \\alpha + \\beta X + \\varepsilon \\] この\\(\\varepsilon\\)は誤差項（撹乱項）と呼ばれる。誤差項は、期待値が0, 分散が一定, 異なった誤差項は無相関、という条件を満たす確率変数である。 このように、母集団における関係のモデル化ができたが、統計的推定の項で説明したように、我々は母集団の真の姿はわからない。しかし、手元にはデータ（サンプル）がある。データを使って、これらの係数を推定することで、母集団における関係を把握しようとするのが回帰分析の統計的な手続きである。 変数Yのデータを\\(y_i\\), Xのデータを\\(x\\)と表記しよう。\\(i\\)は何番目のデータかを表す添字である。 データを用いると我々は以下のような式を推定することになる。 \\[ y_{i} = \\alpha + \\beta x_{i} + \\varepsilon_{i} \\] どのように推定するかは後に説明するが、データを用いて推定された結果、以下のような結果を得ることになる。 \\[ y_{i} = \\hat{\\alpha} + \\hat{\\beta} x_{i} + \\hat{e}_{i} \\] ^はハットと読む。このハットは、ここでは「推定値」であることを示す。母集団におけるモデルの係数という知りたいがわからないものの数値を、手元のサンプルを使って推定した結果であることを示している。 また、一番最後の\\(\\varepsilon_{i}\\)だったものが、\\(\\hat{e}_{i}\\)に変わっていることに気づいただろうか。 これは、残差と呼ばれるもので、誤差項の推定値となるものである。 11.1.1 Rによる単回帰モデルの推定 まずは、Rで実際にやってみて、結果を解釈しながら理解していこう。 Rで回帰分析をする方法はたくさんあるが、まずはもっともシンプルな方法としてRに標準搭載されているlm()関数で推定する。 まずはsimple_reg.Rというスクリプトを作成しよう。 そして、よく使うライブラリを読み込んでおく。 library(tidyverse) データをダウンロードする。 # dataフォルダを作成していない場合はdataフォルダ（ディレクトリ）の作成 fs::dir_create(&quot;data&quot;) # データのダウンロードとdataフォルダへの保存 download.file(&quot;https://github.com/keita43a/regression_tutorial/blob/main/data/ice_cream.csv?raw=TRUE&quot;, destfile=&quot;data/ice_cream.csv&quot;) ダウンロードしたデータを読み込む。 次に、データを読み込む。 dat_ice = read_csv(&quot;data/ice_cream.csv&quot;) まずはデータを確認する。 # データの変数の名前のリスト names(dat_ice) ## [1] &quot;day&quot; &quot;temp&quot; &quot;ice&quot; &quot;accident&quot; # データの冒頭だけ見てチェック head(dat_ice) ## # A tibble: 6 × 4 ## day temp ice accident ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 6.7 207. 0 ## 2 2 32.3 565. 135 ## 3 3 15.4 335. 28 ## 4 4 13.1 88.5 33 ## 5 5 24.1 341. 68 ## 6 6 24.2 438. 42 それぞれ、day(日), temp(気温), ice (アイスクリームの売上), accident (水難事故件数)というデータが記録されている。 それでは、気温とアイスクリームの売上の関係を見る散布図を描いてみよう。 ggplot(data=dat_ice, aes(x = temp, y=ice)) + geom_point() 上でも見たように、気温が上がればアイスクリームの売上が上がるという右肩上がりの関係がある。 単回帰分析でやろうとしているのは、この関係を定量的に把握して、線を引くことである。 今書いたggplotのコードに、geom_smooth(method=\"lm\",se=FALSE)というレイヤーを加えてみよう。 ggplot(data=dat_ice,aes(x = temp, y=ice)) + geom_point() + geom_smooth(method=&quot;lm&quot;,se=FALSE) # 追加！ 青い線が表示された。これは実質的にはggplotの機能として、単回帰直線を推定して、それを描画するということを行っている。 では、実際に回帰分析を行ってみよう。 Rでは、回帰分析を行う関数の中で、目的変数と説明変数の関係をy ~ xのように波線で挟んで書く。 data引数で使うデータを指定し、その中のどの変数をそれぞれ目的変数と説明変数にするかを指定する。 推定した結果は、reg1というオブジェクトに格納してから、表示しよう。 reg1 &lt;- lm(ice ~ temp, data = dat_ice) reg1 ## ## Call: ## lm(formula = ice ~ temp, data = dat_ice) ## ## Coefficients: ## (Intercept) temp ## 7.583 19.645 すると、結果として、Callという部分とCoefficientsという部分に分かれた結果が表示される。 結果はCoefficientsの部分である。 ここでは、(Intercept)というのは切片のことであり、上の式の\\(\\hat{\\alpha}\\)にあたる推定値である。 回帰直線の傾きを表す係数の推定値\\(\\hat{\\beta}\\)は、tempの下に表示されている。 すなわち、この結果から、以下のような推定値が得られたことになる。 \\[ y_{i} = 11.37 + 18.69 \\times x_{i} + \\hat{e}_{i} \\] これを素直に解釈すると、「気温が１℃上がると、アイスクリームの売上が18.69万円上昇する」ということができる。 11.1.2 回帰係数の統計的な推定 まず係数の推定結果を出して、推定することができた。 ここで推定されたreg1に入っているlmオブジェクトは、summary()関数を適用することでさらに詳細な内容を見ることができる。 summary(reg1) ## ## Call: ## lm(formula = ice ~ temp, data = dat_ice) ## ## Residuals: ## Min 1Q Median 3Q Max ## -235.15 -69.57 15.17 66.73 187.50 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 7.5832 17.7088 0.428 0.669 ## temp 19.6445 0.7882 24.922 &lt;0.0000000000000002 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 89.82 on 98 degrees of freedom ## Multiple R-squared: 0.8637, Adjusted R-squared: 0.8623 ## F-statistic: 621.1 on 1 and 98 DF, p-value: &lt; 0.00000000000000022 summaryを適用せずに見た結果と違って、Residualsという項目が追加され、またCoefficientsの内容も拡充されているのがわかる。 ここで大事なのは、Coefficientsに表示されている表である。 先ほどと同様に\\(\\hat{\\alpha}\\)と\\(\\hat{\\beta}\\)が表示されているが、推定値以外のものも表示されているために表形式になっている。 Estimateは文字通り推定値であり、先ほど表示されていた数値が入っている。 Std. Errorは推定値それぞれの標準誤差である。 また、t valueはそれぞれの推定値に対して、帰無仮説を0とした場合のt値が表示されており、それに基づいたp値が入っているのがPr(&gt;|t|)の列である。 ここでe-16と表示されているのは10の-16乗を表しており、&lt;がついていることから、p値がとても小さいことを表している。 また、p値の大きさに基づいて*（アスタリスクであるが、慣例的にスターと呼ぶ）が振られている。 この結果であれば、切片の推定値は統計的には帰無仮説である\\(\\alpha=0\\)を棄却できないが、\\(\\beta=0\\)は有意水準1%であっても棄却することができるということになる。 この仮説検定は「推定された数値が0かどうか」ということを検定する。ある推定値が0かどうかは結果に重要な意味をもたらす。ここでは、気温とアイスクリームの関係を推定しているわけであるが、もし\\(\\beta=0\\)ならば、気温が何度であろうがアイスクリームの売上に関係ないことになってしまう。 因果関係を推定する上で、興味のある係数（ここでは\\(\\beta\\)）がゼロかどうか、傾きがあるかどうか、は重要なポイントとなるため、この仮説検定は重要である。 11.1.3 見せかけの相関と単回帰分析 上で説明した見せかけの相関のある変数同士であっても、単回帰分析で推定すること自体は可能である。 上でみたように、アイスクリームの売上と水難事故の件数を単回帰分析してみよう。ここでは水難事故の件数を目的変数として推定してみる。 reg2 &lt;- lm(accident ~ ice, data = dat_ice) summary(reg2) ## ## Call: ## lm(formula = accident ~ ice, data = dat_ice) ## ## Residuals: ## Min 1Q Median 3Q Max ## -58.235 -20.513 -2.319 18.319 82.187 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.49169 5.71410 -0.786 0.434 ## ice 0.10141 0.01251 8.104 0.00000000000152 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 30.14 on 98 degrees of freedom ## Multiple R-squared: 0.4013, Adjusted R-squared: 0.3952 ## F-statistic: 65.68 on 1 and 98 DF, p-value: 0.00000000000152 結果を見てみると、傾きの係数は0.10141となっている。 素直に解釈すると、アイスクリームの売上が1万円上がると水難事故件数が約0.1件上がる、もしくは売上が10万円上がると水難事故が約1件増えるということになる。 しかし、上で議論したようにそんな因果関係があるわけではない。しかし、単回帰分析として推定してしまうと、それらしい数字が推定され、統計的にも優位になってしまっている。 だからこそ、単純にデータを単回帰分析して結果を解釈することは危険であり、分析するためにどういうロジックでその仮説が導かれるかを吟味する必要がある。また、その仮説が他の変数などに影響される見せかけの相関の可能性はないかどうかを十分に検討する必要がある。 11.2 回帰分析の推定方法 回帰分析はどのように推定されるのであろうか。もっと簡単に言い換えれば、どういう基準で散布図に”適切な”線を引くことができるのか。 回帰分析は一般的には最小二乗法という方法で推定されている。 上で説明したように、母集団における単回帰モデルは、切片と係数と説明変数（すなわち直線部分）で説明できる部分と、説明できない部分（誤差項）がある。 最小二乗法は、この説明できない部分の二乗の合計が最も小さくなるような直線を引く、というアイデアである。 下の図は、気温とアイスクリームの売上のデータのうち、最初の10個だけを取り出したものである。 各点はそれぞれのデータポイントを表している。引かれている直線は回帰直線であるが、この直線が通っているところと実際のデータポイントとの目的変数の差が「残差」となる。当然ながら、どうやって直線を引くかによって残差は変わるが、もっとも残差の合計が小さくなるところが「適切な」線だという考え方である。 引かれた線よりも上や下にデータポイントが散らばるので、そのまま合計すると打ち消し合ってしまうため、実際の「距離」として測ることが難しい。しかし、二乗すれば負の値も正になるため、二乗してから合計することで直線の上下関係なくどれぐらい離れているかという残差を評価することができる。 厳密にどのように推定しているかはここでは省略するが、統計学や計量経済学の教科書を見て理解を進めてほしい。 11.3 演習問題：単回帰分析 AERパッケージを読み込む。インストールしていない場合はインストールする。 data()関数を使って、CASchoolsというAERパッケージに付属しているデータを読み込む。これは、カリフォルニア州の学校ごとの学生数などのデータである。 tidyverseパッケージの関数を使って、学生数studentsと教員数teachersの比を計算し、STRという変数にする。また、国語readと数学mathを足して２で割ったスコアをscoreという変数にする。新たに作成したデータをdat_schoolとして保存する。 ggplotを用いて、x軸をSTR, y軸をscoreとする散布図を描く。以下のような図になるはずである（背景色やラベルなどは同じでなくてよい） STRを説明変数、scoreを目的変数とする単回帰分析を行い、summary()関数を用いて結果を表示しなさい。 5.の結果を解釈しなさい。 "],["multipleregression.html", "Chapter 12 重回帰分析 12.1 重回帰分析とは 12.2 回帰分析における真のモデル", " Chapter 12 重回帰分析 12.1 重回帰分析とは 重回帰分析は、単純に言えば説明変数が２つ以上ある回帰式を用いる回帰分析である。 しかし、重回帰分析は、単純に多くの変数を入れることで、目的変数を説明できる部分が増える、というような目的で用いられるのではない。 特に、実証分析における因果推定では、重回帰分析における係数が、他の説明変数の影響を除いた影響として推定されることが重要である。 12.2 回帰分析における真のモデル 回帰分析では、そのデータを生み出している元となる存在があると考える(専門用語ではData Generating Processと呼ぶ)。 これは、現象を起こすメカニズムが存在し、そのメカニズムは神のみぞ知ると考えていると言ってもよい。 私たち分析者は、神のみぞ知るメカニズムに迫ろうとしているのだ。 実際の社会で起こっているメカニズムの本当の姿は（真のモデル）は、神のみぞ知るが、シミュレーションによる仮想世界を作ってその世界の真のメカニズムを知りながら、分析をすることはできる。いわば、仮想世界では神になることができるのだ。 12.2.1 シミュレーション 12.2.1.1 準備 まず、multi_reg.Rというスクリプトを作って保存しよう。 そして、以下のパッケージを読み込む。 library(tidyverse) library(fixest) library(skimr) 12.2.1.2 データの生成 今から行うのは、以下のような真のモデルがあると仮定して、データを生成することである。 ここでは、あるスーパーマーケットチェーンのお店ごとのデータを生成するとしよう。このスーパーマーケットチェーンでは全国で300店舗展開しているとする。 300店舗のうち、一部の店舗では広告を出稿することにした。ここで分析しようとしているのは、広告を出すことによって平均的に売上が上がるのかどうかである。 当然ながら売上は広告だけでは決まらない。ここでは、「神」となってデータを生成してみよう。 各店舗\\(i\\)の売上は、以下のモデルで決まるとしよう。これが「真のモデル」である。 \\[ Sales_i = \\alpha + \\beta_1 Ads_i + \\beta_2 Age_i + \\beta_3 Income_i + \\varepsilon_i \\] \\(Sales_i\\)は店舗\\(i\\)の売上、\\(Ads_i\\)は広告を出したかというダミー変数で出向していれば1, していなければ0を取る。\\(Age_i\\)は店長の年齢である。\\(Income_i\\)はその店舗が出店している地域の平均所得だとしよう。 単純なモデルであるが売上は、広告、店長の年齢、地域の平均所得で決まるとしよう。 しかし、広告を出すかどうか、という意思決定は外生的に決まらない。外生的とは、モデルの外で天から降ってきたように決まることをいう。しかし、この広告を出すかどうかは内生的に決まるものだとしよう。モデルの中の変数によって決まるとする。 \\[ Ads_i = I\\{100 \\leq \\gamma_1 Age_i + \\gamma_2 Income_i + u_i\\} \\] すこしややこしい数式だが、この数式が言っているのは次のとおりだ。店長の年齢と地域の平均所得で決まる数値が100より大きい店舗では広告を出稿する。 そして、仮想世界の神であるので、このモデルのパラメーターの数値を決めることができる。 以下のようにパラメーターの数値を決めた。 # パラメーターの数値 a1&lt;-500 b1&lt;-50 b2&lt;-5 b3&lt;-0.09 g1 &lt;- 1 g2 &lt;- 0.1 N2&lt;-300 そして、いよいよデータの生成である。 データの生成には確率的な要素も入れ込むが、再現性を担保するためにシード値を決めておく。 # シードの固定 set.seed(3) そして、以下のようにデータを生成する。 少し説明が難しい要素もあるので、ここはコピー&amp;ペーストでよいので自分のスクリプトに貼り付けて実行してみよう。 実行する際は、かならず上のset.seed(3)を実行してから実行すること。 # シミュレーションデータの作成 dat_sim = tibble( shop_ID = 1:N2, age = round(runif(N2,25,60)), income = round(runif(N2,15,100))*10, pop = round(runif(N2,10,1000))*100, dogs = round(runif(N2,0,0.5),digits=2), u_ads = rnorm(N2,0,sd=10), z_ads = round(g1*age+g2*income,digits=1), y_ads = z_ads + u_ads, ads = ifelse(100 &lt;= y_ads,1,0), epsilon = rnorm(N2,sd=20), sales = round(a1 + b1*ads + b2*age + b3*income + epsilon,digits=1) ) %&gt;% select(!contains(&quot;_ads&quot;) &amp; !starts_with(&quot;u&quot;)) %&gt;% relocate(ads, .before=age) ここでは、上のモデルで使った変数に加えて、popという地域の人口に当たる変数と、dogsという地域の犬を飼っている割合という変数も生成している。 データの記述統計を見てみよう。 skim(dat_sim) Table 12.1: Data summary Name dat_sim Number of rows 300 Number of columns 8 _______________________ Column type frequency: numeric 8 ________________________ Group variables None Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist shop_ID 0 1 150.50 86.75 1.00 75.75 150.50 225.25 300.00 ▇▇▇▇▇ ads 0 1 0.53 0.50 0.00 0.00 1.00 1.00 1.00 ▇▁▁▁▇ age 0 1 42.11 9.81 25.00 34.00 42.00 51.00 60.00 ▇▇▇▇▆ income 0 1 603.23 251.09 150.00 397.50 625.00 832.50 1000.00 ▆▇▆▆▇ pop 0 1 49726.00 28658.81 1200.00 26000.00 48950.00 74075.00 100000.00 ▇▇▇▇▇ dogs 0 1 0.24 0.14 0.00 0.13 0.25 0.35 0.50 ▇▇▇▆▆ epsilon 0 1 -1.28 20.71 -64.81 -16.14 -0.31 12.57 51.91 ▁▅▇▇▁ sales 0 1 789.90 73.83 624.80 735.03 789.45 846.12 961.00 ▃▆▇▆▂ 12.2.1.3 回帰モデルの推定 ここでの疑問は「広告の出稿は売上増加に貢献するか」であった。 普通のデータなら、真のモデルはわからないが、ここでは我々は神なので真のモデルがわかっている。 まず、このデータから真のモデルと同じモデルを推定してみよう。 model_true &lt;- feols(sales ~ ads + age + income, data = dat_sim) etable(model_true) ## model_true ## Dependent Var.: sales ## ## Constant 499.6*** (6.860) ## ads 49.66*** (4.028) ## age 4.985*** (0.1299) ## income 0.0899*** (0.0078) ## _______________ __________________ ## S.E. type IID ## Observations 300 ## R2 0.92132 ## Adj. R2 0.92052 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 設定したパラメーターに近い数値が推定されている。 真のモデルを知っていれば広告の効果は50であるとわかる。 また、真のモデルに基づいたデータ分析でも推定値は49.66と非常に近い値が推定されている。 しかし、本当は分析者は真のモデルは知らない。 一般的には、単回帰分析から始めるが、単回帰分析をしてみるとどうなるだろうか。 \\[ Sales_i = \\alpha + \\beta_1 Ads_i + \\varepsilon_i \\] 練習問題: 説明変数を広告とした単回帰モデルを推定し、結果を表示させなさい ## model_1 ## Dependent Var.: sales ## ## Constant 733.4*** (4.261) ## ads 107.3*** (5.872) ## _______________ ________________ ## S.E. type IID ## Observations 300 ## R2 0.52853 ## Adj. R2 0.52694 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 推定値は107と出た。これは真の値である50に比べると２倍以上である。 つまり、このモデルでは広告の効果を２倍以上見積もっていることになる。 何度も言うように、本来ならば分析者は真のモデルや真の値を知らない。 そのため、単純に単回帰モデルを分析して、結果を解釈すると「広告の出稿は107万円の売上を増加させる」という間違った結果を得てしまう。 次に、分析者は他の変数を含めてみようと思うかもしれない。 地域の人口が売上に影響を与えていそうだ、という思って次のような重回帰モデルを推定するとしよう。 \\[ Sales_i = \\alpha + \\beta_1 Ads_i + \\beta_4 Pop_i + \\varepsilon_i \\] 練習問題: 説明変数を広告と人口(pop)とした重回帰モデルを推定し、結果を表示させなさい ## model_2 ## Dependent Var.: sales ## ## Constant 737.1*** (6.782) ## ads 107.1*** (5.885) ## pop -7.32e-5 (0.0001) ## _______________ _________________ ## S.E. type IID ## Observations 300 ## R2 0.52933 ## Adj. R2 0.52616 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 結果は、popの係数の数値は非常に小さく、また統計的にゼロである可能性を棄却できなかった。 また、広告の効果も単回帰とは変わらない。 次に、分析者は店長の年齢は経験値などに比例しているので売上に関係があると思ったとする。 そこで、次に店長の年齢ageを含めたモデルを推定する。 練習問題: 説明変数を広告、人口(pop)、店長の年齢(age)とした重回帰モデルを推定し、結果を表示させなさい ## model_3 ## Dependent Var.: sales ## ## Constant 552.0*** (6.929) ## ads 86.14*** (2.977) ## pop -4.28e-5 (5.06e-5) ## age 4.623*** (0.1516) ## _______________ __________________ ## S.E. type IID ## Observations 300 ## R2 0.88635 ## Adj. R2 0.88519 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 models_ads = list() models_ads[[&quot;Model 1&quot;]] = feols(sales ~ ads, se=&quot;iid&quot;, data=dat_sim) models_ads[[&quot;Model 2&quot;]] = feols(sales ~ ads + age, se=&quot;iid&quot;, data=dat_sim) models_ads[[&quot;Model 3&quot;]] = feols(sales ~ ads + age + income, se=&quot;iid&quot;, data=dat_sim) models_ads[[&quot;Model 4&quot;]] = feols(sales ~ ads + age + income + pop, se=&quot;iid&quot;, data=dat_sim) models_ads[[&quot;Model 5&quot;]] = feols(sales ~ ads + age + income + pop + dogs, se=&quot;iid&quot;, data=dat_sim) etable(models_ads) ## Model 1 Model 2 Model 3 Model 4 Model 5 ## Dependent Var.: sales sales sales sales sales ## ## Constant 733.4*** (4.261) 549.7*** (6.372) 499.6*** (6.860) 501.6*** (7.241) 503.3*** (7.492) ## ads 107.3*** (5.872) 86.26*** (2.973) 49.66*** (4.028) 49.59*** (4.030) 49.58*** (4.031) ## age 4.625*** (0.1515) 4.985*** (0.1299) 4.982*** (0.1300) 4.982*** (0.1301) ## income 0.0899*** (0.0078) 0.0898*** (0.0078) 0.0901*** (0.0078) ## pop -3.7e-5 (4.21e-5) -3.67e-5 (4.21e-5) ## dogs -7.638 (8.689) ## _______________ ________________ _________________ __________________ __________________ __________________ ## S.E. type IID IID IID IID IID ## Observations 300 300 300 300 300 ## R2 0.52853 0.88607 0.92132 0.92152 0.92173 ## Adj. R2 0.52694 0.88530 0.92052 0.92046 0.92040 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],["paneldata.html", "Chapter 13 パネルデータ分析 13.1 パネルデータとは 13.2 パネルデータ分析 13.3 固定効果モデル", " Chapter 13 パネルデータ分析 13.1 パネルデータとは 重回帰分析のセクションで扱ったデータは基本的にはクロスセクションデータであった。 これは、データの変動が人であったり、県であったり、グループであったりするものであり、データでは添字\\(i\\)で表現していた。 これに加えて、時間の変動藻ある場合には、クロスセクションデータで分析するよりアドバンテージがある。時間変動がある場合にどのような形になるか見てみよう。 13.1.1 スクリプトの準備 新しいスクリプトにコードを書いていく。 新しくスクリプトを作成し、panel_data.Rという名前をつけて保存する。 13.1.2 パッケージの準備 以下のパッケージを使うので読み込んでおく。 インストールしてない場合は、インストールする。 # ライブラリ library(tidyverse) library(psych) library(skimr) library(AER) library(fixest) 13.1.3 データの準備 データを読み込む。データ名が長いので、 data_fに入れ替えよう。 data(Fatalities) data_f &lt;- Fatalities データの中身を見てみる。 まずは、どんなデータなのかhead()で確認する。 head(data_f) ## state year spirits unemp income emppop beertax baptist mormon drinkage dry youngdrivers miles breath jail service fatal nfatal sfatal fatal1517 ## 1 al 1982 1.37 14.4 10544.15 50.69204 1.539379 30.3557 0.32829 19.00 25.0063 0.211572 7233.887 no no no 839 146 99 53 ## 2 al 1983 1.36 13.7 10732.80 52.14703 1.788991 30.3336 0.34341 19.00 22.9942 0.210768 7836.348 no no no 930 154 98 71 ## 3 al 1984 1.32 11.1 11108.79 54.16809 1.714286 30.3115 0.35924 19.00 24.0426 0.211484 8262.990 no no no 932 165 94 49 ## 4 al 1985 1.28 8.9 11332.63 55.27114 1.652542 30.2895 0.37579 19.67 23.6339 0.211140 8726.917 no no no 882 146 98 66 ## 5 al 1986 1.23 9.8 11661.51 56.51450 1.609907 30.2674 0.39311 21.00 23.4647 0.213400 8952.854 no no no 1081 172 119 82 ## 6 al 1987 1.18 7.8 11944.00 57.50988 1.560000 30.2453 0.41123 21.00 23.7924 0.215527 9166.302 no no no 1110 181 114 94 ## nfatal1517 fatal1820 nfatal1820 fatal2124 nfatal2124 afatal pop pop1517 pop1820 pop2124 milestot unempus emppopus gsp ## 1 9 99 34 120 32 309.438 3942002 208999.6 221553.4 290000.1 28516 9.7 57.8 -0.02212476 ## 2 8 108 26 124 35 341.834 3960008 202000.1 219125.5 290000.2 31032 9.6 57.9 0.04655825 ## 3 7 103 25 118 34 304.872 3988992 197000.0 216724.1 288000.2 32961 7.5 59.5 0.06279784 ## 4 9 100 23 114 45 276.742 4021008 194999.7 214349.0 284000.3 35091 7.2 60.1 0.02748997 ## 5 10 120 23 119 29 360.716 4049994 203999.9 212000.0 263000.3 36259 7.0 60.7 0.03214295 ## 6 11 127 31 138 30 368.421 4082999 204999.8 208998.5 258999.8 37426 6.2 61.5 0.04897637 このデータはアメリカの州×年ごとに、様々な変数が記録されているデータである。 どんな変数が記録されているかは、helpファイルを見るとわかる。 help(Fatalities) 13.1.4 データの記述統計 データの記述統計を確認しよう。一番基本的なものはsummary()関数を使う方法である。 summary(data_f) ## state year spirits unemp income emppop beertax baptist mormon drinkage ## al : 7 1982:48 Min. :0.790 Min. : 2.400 Min. : 9514 Min. :42.99 Min. :0.04331 Min. : 0.0000 Min. : 0.1000 Min. :18.00 ## az : 7 1983:48 1st Qu.:1.300 1st Qu.: 5.475 1st Qu.:12086 1st Qu.:57.69 1st Qu.:0.20885 1st Qu.: 0.6268 1st Qu.: 0.2722 1st Qu.:20.00 ## ar : 7 1984:48 Median :1.670 Median : 7.000 Median :13763 Median :61.36 Median :0.35259 Median : 1.7492 Median : 0.3931 Median :21.00 ## ca : 7 1985:48 Mean :1.754 Mean : 7.347 Mean :13880 Mean :60.81 Mean :0.51326 Mean : 7.1569 Mean : 2.8019 Mean :20.46 ## co : 7 1986:48 3rd Qu.:2.013 3rd Qu.: 8.900 3rd Qu.:15175 3rd Qu.:64.41 3rd Qu.:0.65157 3rd Qu.:13.1271 3rd Qu.: 0.6293 3rd Qu.:21.00 ## ct : 7 1987:48 Max. :4.900 Max. :18.000 Max. :22193 Max. :71.27 Max. :2.72076 Max. :30.3557 Max. :65.9165 Max. :21.00 ## (Other):294 1988:48 ## dry youngdrivers miles breath jail service fatal nfatal sfatal fatal1517 ## Min. : 0.00000 Min. :0.07314 Min. : 4576 no :181 no :241 no :273 Min. : 79.0 Min. : 13.00 Min. : 8.0 Min. : 3.00 ## 1st Qu.: 0.00000 1st Qu.:0.17037 1st Qu.: 7183 yes:155 yes : 94 yes : 62 1st Qu.: 293.8 1st Qu.: 53.75 1st Qu.: 35.0 1st Qu.: 25.75 ## Median : 0.08681 Median :0.18539 Median : 7796 NA&#39;s: 1 NA&#39;s: 1 Median : 701.0 Median : 135.00 Median : 81.0 Median : 49.00 ## Mean : 4.26707 Mean :0.18593 Mean : 7891 Mean : 928.7 Mean : 182.58 Mean :109.9 Mean : 62.61 ## 3rd Qu.: 2.42481 3rd Qu.:0.20219 3rd Qu.: 8504 3rd Qu.:1063.5 3rd Qu.: 212.00 3rd Qu.:131.0 3rd Qu.: 77.00 ## Max. :45.79210 Max. :0.28163 Max. :26148 Max. :5504.0 Max. :1049.00 Max. :603.0 Max. :318.00 ## ## nfatal1517 fatal1820 nfatal1820 fatal2124 nfatal2124 afatal pop pop1517 pop1820 ## Min. : 0.00 Min. : 7.0 Min. : 0.00 Min. : 12.0 Min. : 1.00 Min. : 24.6 Min. : 479000 Min. : 21000 Min. : 21000 ## 1st Qu.: 4.00 1st Qu.: 38.0 1st Qu.: 11.00 1st Qu.: 42.0 1st Qu.: 13.00 1st Qu.: 90.5 1st Qu.: 1545251 1st Qu.: 71750 1st Qu.: 76962 ## Median :10.00 Median : 82.0 Median : 24.00 Median : 97.5 Median : 30.00 Median : 211.6 Median : 3310503 Median : 163000 Median : 170982 ## Mean :12.26 Mean :106.7 Mean : 33.53 Mean :126.9 Mean : 41.38 Mean : 293.3 Mean : 4930272 Mean : 230816 Mean : 249090 ## 3rd Qu.:15.25 3rd Qu.:130.2 3rd Qu.: 44.00 3rd Qu.:150.5 3rd Qu.: 49.00 3rd Qu.: 364.0 3rd Qu.: 5751735 3rd Qu.: 270500 3rd Qu.: 308311 ## Max. :76.00 Max. :601.0 Max. :196.00 Max. :770.0 Max. :249.00 Max. :2094.9 Max. :28314028 Max. :1172000 Max. :1321004 ## ## pop2124 milestot unempus emppopus gsp ## Min. : 30000 Min. : 3993 Min. :5.500 Min. :57.80 Min. :-0.123641 ## 1st Qu.: 103500 1st Qu.: 11692 1st Qu.:6.200 1st Qu.:57.90 1st Qu.: 0.001182 ## Median : 241000 Median : 28484 Median :7.200 Median :60.10 Median : 0.032413 ## Mean : 336390 Mean : 37101 Mean :7.529 Mean :59.97 Mean : 0.025313 ## 3rd Qu.: 413000 3rd Qu.: 44140 3rd Qu.:9.600 3rd Qu.:61.50 3rd Qu.: 0.056501 ## Max. :1892998 Max. :241575 Max. :9.700 Max. :62.30 Max. : 0.142361 ## Chapter @ref(#rstats) で説明したように、他のパッケージを使う方法もある。 describe(data_f, skew = FALSE) ## vars n mean sd median min max range se ## state* 1 336 24.50 13.87 24.50 1.00 48.00 47.00 0.76 ## year* 2 336 4.00 2.00 4.00 1.00 7.00 6.00 0.11 ## spirits 3 336 1.75 0.68 1.67 0.79 4.90 4.11 0.04 ## unemp 4 336 7.35 2.53 7.00 2.40 18.00 15.60 0.14 ## income 5 336 13880.18 2253.05 13763.13 9513.76 22193.46 12679.69 122.91 ## emppop 6 336 60.81 4.72 61.36 42.99 71.27 28.28 0.26 ## beertax 7 336 0.51 0.48 0.35 0.04 2.72 2.68 0.03 ## baptist 8 336 7.16 9.76 1.75 0.00 30.36 30.36 0.53 ## mormon 9 336 2.80 9.67 0.39 0.10 65.92 65.82 0.53 ## drinkage 10 336 20.46 0.90 21.00 18.00 21.00 3.00 0.05 ## dry 11 336 4.27 9.50 0.09 0.00 45.79 45.79 0.52 ## youngdrivers 12 336 0.19 0.02 0.19 0.07 0.28 0.21 0.00 ## miles 13 336 7890.75 1475.66 7796.22 4576.35 26148.27 21571.93 80.50 ## breath* 14 336 1.46 0.50 1.00 1.00 2.00 1.00 0.03 ## jail* 15 335 1.28 0.45 1.00 1.00 2.00 1.00 0.02 ## service* 16 335 1.19 0.39 1.00 1.00 2.00 1.00 0.02 ## fatal 17 336 928.66 934.05 701.00 79.00 5504.00 5425.00 50.96 ## nfatal 18 336 182.58 188.43 135.00 13.00 1049.00 1036.00 10.28 ## sfatal 19 336 109.95 108.54 81.00 8.00 603.00 595.00 5.92 ## fatal1517 20 336 62.61 55.73 49.00 3.00 318.00 315.00 3.04 ## nfatal1517 21 336 12.26 12.25 10.00 0.00 76.00 76.00 0.67 ## fatal1820 22 336 106.66 104.22 82.00 7.00 601.00 594.00 5.69 ## nfatal1820 23 336 33.53 33.24 24.00 0.00 196.00 196.00 1.81 ## fatal2124 24 336 126.87 131.79 97.50 12.00 770.00 758.00 7.19 ## nfatal2124 25 336 41.38 42.93 30.00 1.00 249.00 248.00 2.34 ## afatal 26 336 293.33 303.58 211.59 24.60 2094.90 2070.30 16.56 ## pop 27 336 4930271.50 5073703.89 3310503.25 478999.72 28314028.00 27835028.28 276793.24 ## pop1517 28 336 230815.48 229896.27 163000.17 21000.02 1172000.25 1151000.23 12541.87 ## pop1820 29 336 249090.42 249345.64 170982.34 20999.96 1321004.38 1300004.41 13602.92 ## pop2124 30 336 336389.89 345304.37 240999.90 30000.16 1892998.12 1862997.97 18837.90 ## milestot 31 336 37101.49 37454.37 28483.50 3993.00 241575.02 237582.02 2043.30 ## unempus 32 336 7.53 1.48 7.20 5.50 9.70 4.20 0.08 ## emppopus 33 336 59.97 1.59 60.10 57.80 62.30 4.50 0.09 ## gsp 34 336 0.03 0.04 0.03 -0.12 0.14 0.27 0.00 psychパッケージのdescribe()では、カテゴリー変数も無理やり数値化して計算するのでおかしなことになっているものがあることである。例えば、stateは州なので、平均や標準偏差が計算されているのはおかしい。 しかし、数値の変数を見るときには有用である。 skimrパッケージのskim()関数は、カテゴリ変数と連続変数を区別して記述統計を示してくれる。 library(skimr) skim(data_f) Table 13.1: Data summary Name data_f Number of rows 336 Number of columns 34 _______________________ Column type frequency: factor 5 numeric 29 ________________________ Group variables None Variable type: factor skim_variable n_missing complete_rate ordered n_unique top_counts state 0 1 FALSE 48 al: 7, az: 7, ar: 7, ca: 7 year 0 1 FALSE 7 198: 48, 198: 48, 198: 48, 198: 48 breath 0 1 FALSE 2 no: 181, yes: 155 jail 1 1 FALSE 2 no: 241, yes: 94 service 1 1 FALSE 2 no: 273, yes: 62 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist spirits 0 1 1.75 0.68 0.79 1.30 1.67 2.01 4.90 ▇▇▁▁▁ unemp 0 1 7.35 2.53 2.40 5.48 7.00 8.90 18.00 ▅▇▃▁▁ income 0 1 13880.18 2253.05 9513.76 12085.85 13763.13 15175.12 22193.46 ▅▇▅▂▁ emppop 0 1 60.81 4.72 42.99 57.69 61.36 64.41 71.27 ▁▁▆▇▂ beertax 0 1 0.51 0.48 0.04 0.21 0.35 0.65 2.72 ▇▂▁▁▁ baptist 0 1 7.16 9.76 0.00 0.63 1.75 13.13 30.36 ▇▁▁▁▁ mormon 0 1 2.80 9.67 0.10 0.27 0.39 0.63 65.92 ▇▁▁▁▁ drinkage 0 1 20.46 0.90 18.00 20.00 21.00 21.00 21.00 ▁▂▁▁▇ dry 0 1 4.27 9.50 0.00 0.00 0.09 2.42 45.79 ▇▁▁▁▁ youngdrivers 0 1 0.19 0.02 0.07 0.17 0.19 0.20 0.28 ▁▁▇▃▁ miles 0 1 7890.75 1475.66 4576.35 7182.54 7796.22 8504.02 26148.27 ▇▂▁▁▁ fatal 0 1 928.66 934.05 79.00 293.75 701.00 1063.50 5504.00 ▇▂▁▁▁ nfatal 0 1 182.58 188.43 13.00 53.75 135.00 212.00 1049.00 ▇▂▁▁▁ sfatal 0 1 109.95 108.54 8.00 35.00 81.00 131.00 603.00 ▇▂▁▁▁ fatal1517 0 1 62.61 55.73 3.00 25.75 49.00 77.00 318.00 ▇▃▁▁▁ nfatal1517 0 1 12.26 12.25 0.00 4.00 10.00 15.25 76.00 ▇▂▁▁▁ fatal1820 0 1 106.66 104.22 7.00 38.00 82.00 130.25 601.00 ▇▂▁▁▁ nfatal1820 0 1 33.53 33.24 0.00 11.00 24.00 44.00 196.00 ▇▂▁▁▁ fatal2124 0 1 126.87 131.79 12.00 42.00 97.50 150.50 770.00 ▇▂▁▁▁ nfatal2124 0 1 41.38 42.93 1.00 13.00 30.00 49.00 249.00 ▇▂▁▁▁ afatal 0 1 293.33 303.58 24.60 90.50 211.59 363.96 2094.90 ▇▁▁▁▁ pop 0 1 4930271.50 5073703.89 478999.72 1545251.47 3310503.25 5751734.88 28314028.00 ▇▁▁▁▁ pop1517 0 1 230815.48 229896.27 21000.02 71749.93 163000.17 270500.16 1172000.25 ▇▂▁▁▁ pop1820 0 1 249090.42 249345.64 20999.96 76962.12 170982.34 308311.35 1321004.38 ▇▂▁▁▁ pop2124 0 1 336389.89 345304.37 30000.16 103500.04 240999.90 413000.12 1892998.12 ▇▂▁▁▁ milestot 0 1 37101.49 37454.37 3993.00 11691.50 28483.50 44139.75 241575.02 ▇▂▁▁▁ unempus 0 1 7.53 1.48 5.50 6.20 7.20 9.60 9.70 ▇▃▇▁▇ emppopus 0 1 59.97 1.59 57.80 57.90 60.10 61.50 62.30 ▇▃▃▃▇ gsp 0 1 0.03 0.04 -0.12 0.00 0.03 0.06 0.14 ▁▂▆▇▁ 13.1.5 データの加工 データには、交通事故による死亡数fatalはあるが、死亡率がない。当然ながら各州によって人口が違い、人口が多い州は死亡数も多くなる。州の間で比較を行うためには、死亡数より死亡率が適切だろう。そこで、死亡率fatal_rateを死亡数fatalを人口popで割ることで計算する。あまりに小さい数字になるため10000をかけて「１万人当たりの死亡者数」として死亡率を定義する。 新たに追加したデータをdata_f2に入れる。 # データの加工 data_f2 &lt;- data_f |&gt; # 死亡率の計算 mutate(fatal_rate = fatal/pop * 10000) 13.2 パネルデータ分析 13.2.1 事例：交通事故死亡率とアルコール税の関係 ここでは、アメリカの州（アラスカとハワイを除いた48州）の1982~1988年のデータを用いて、各州のアルコール税の税率と、交通事故死亡率の関係を分析する。 ここで、日本とは異なる背景知識だが、アメリカは連邦制の国であり、州によって様々な法律が異なる。例えば消費税のない州もあれば、その税率が州で違ったりもする。この場合はアルコール、特にビールにかかる税率が州で異なる点に着目して、税率の違いが酒酔い運転などによっても引き起こされる交通事故死亡率に影響するかどうかを分析する。 州\\(i\\)の交通事故死亡率を\\(y_{i}\\)とし、ビール税率を\\(x_{i}\\)とすると、以下の単回帰式によって、影響が推定できそうだ。 \\[ y_{i} = \\alpha + \\beta x_{i} +\\varepsilon_{i} \\] ビール税率を上げると交通事故死亡率が下がる、という仮説を検証したい場合、\\(\\beta\\)が負（マイナス）であると期待するだろう。 まず、この単回帰式を推定するために、クロス・セクションのデータで推定を行ってみよう。 データのうち、1982年と1988年をそれぞれ抽出してみよう。 # クロスセクションデータの作成 data_f2_1982 &lt;- data_f2 |&gt; filter(year == 1982) data_f2_1988 &lt;- data_f2 |&gt; filter(year == 1988) このデータを用いて単位回帰分析を行う。 # 回帰分析 # lm()の代わりに feols()を使う # 1982年のデータ reg1_1982 &lt;- feols(fatal_rate ~ beertax, data=data_f2_1982) # 1988年のデータ reg1_1988 &lt;- feols(fatal_rate ~ beertax, data=data_f2_1988) 結果を表示する。 etable(reg1_1982,reg1_1988) ## reg1_1982 reg1_1988 ## Dependent Var.: fatal_rate fatal_rate ## ## Constant 2.010*** (0.1391) 1.859*** (0.1060) ## beertax 0.1485 (0.1884) 0.4388* (0.1645) ## _______________ _________________ _________________ ## S.E. type IID IID ## Observations 48 48 ## R2 0.01332 0.13400 ## Adj. R2 -0.00813 0.11518 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 この結果によれば、1982年ではビール税率が1%上がると、交通事故死亡率が0.1485上昇し、1988年では0.4388上昇する。 このデータは州ごとのクロスセクションデータなので、もう少し正確に解釈すると、ビール税が1%高い州では交通事故死亡率が高い、ということになる。 この結果をグラフでも見てみよう。縦軸を死亡率、横軸をビール税として散布図を描く。ここでは1988年のデータを見てみよう。 ggplot(data=data_f2_1988, aes(x=beertax, y=fatal_rate)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=FALSE)+ labs(x=&quot;ビール税率&quot;, y=&quot;交通事故死亡率(10000人当たり）&quot;) + theme_gray(base_family = &quot;HiraKakuPro-W3&quot;) #&lt;- このレイヤーはWindowsならいらない むしろ税率と交通事故死亡率には正の関係がある。 このアプローチには問題がないだろうか？なぜなら、クロスセクションデータでは州ごとの違いを見ているので、ビール税が高い州では交通事故死亡率が高いという結果であるが、交通事故死亡率が高い州ではビール税を上げているので高いという可能性もある。州による特性もある。 では時間的な変動を含めたデータでは、どうなるだろうか？ 州\\(i\\)の年\\(t\\)における交通事故死亡率を\\(y_{it}\\)とし、ビール税率を\\(x_{it}\\)とすると、以下の単回帰式によって、影響が推定できそうだ。上の式と違うのは添字に\\(t\\)が加わり、時間の変動も加味したデータを使っていることだ。 \\[ y_{it} = \\alpha + \\beta x_{it} +\\varepsilon_{it} \\] # 回帰分析 # lm()の代わりに feols()を使う # 1982-1988年のデータ reg1_panel &lt;- feols(fatal_rate ~ beertax, data=data_f2) 結果を表示する。 etable(reg1_panel) ## reg1_panel ## Dependent Var.: fatal_rate ## ## Constant 1.853*** (0.0436) ## beertax 0.3646*** (0.0622) ## _______________ __________________ ## S.E. type IID ## Observations 336 ## R2 0.09336 ## Adj. R2 0.09065 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 結果は、\\(\\beta\\)に当たるパラメータの推定値が0.3646となり、やはり正の符号となっている。 時間変動を加えても結果は変わっていない、ということはやはりビール税を上げると交通事故死亡率が増えるのだろうか？ 13.3 固定効果モデル ここで、重要なのはデータを変えただけでは本質的な問題である「州の特性によって、死亡率が高い州ほどビール税が高い（上げている）」可能性の影響を推定値から排除できていないことである。 この\\(x_{it}\\)には、州によってはビール税が（年にかかわらず）高い、という特性も入ってしまっており、そのデータが推定値に影響している。ならば、その影響を分けて推定することはできないか。これが固定効果モデルのアイデアである。 固定効果とは、データとしては直接観察されないが時間的に変化しない主体独特の効果である。この場合は時間的に変化しない州独特の効果と言える。ではデータとしては直接観察されないのに、どうやって回帰式に含めるのか？これは、州ごとのダミー変数を作成するという発想で解決する。 固定効果モデルを式として書くと以下のように書くことができる。 \\[ y_{it} = \\gamma_{i} + \\beta x_{it} + \\varepsilon_{it} \\] 切片\\(\\alpha\\)の代わりに、添え字\\(i\\)を持つパラメータ\\(\\gamma\\)が含まれている。これは州ごとに切片が異なる回帰式とも解釈することができる。ここで、州ごとの(交通事故死亡率の)特性の違いが捕捉されるため、ビール税率の係数の推定値はその州ごとの特性を除いた推定値となる。しかし、データではないパラメータに\\(i\\)がついているのはなぜか？ これは実質的には以下のような式を推定しているのと同じである。 \\[ y_{it} = \\beta x_{it} + \\gamma_{AL} D_{AL} + \\gamma_{AZ} D_{AZ} + \\gamma_{AR} D_{AR} + \\cdots + \\gamma_{WY} D_{WY} + + \\varepsilon_{it} \\] もしデータ\\(i\\)がアラバマ州ならば\\(D_{AL}\\)は1になり、それ以外は0になるので、\\(\\gamma_{AL}\\)が式に残る。もし\\(i\\)がアリゾナ州ならば\\(D_{AZ}\\)は1になり、それ以外は0になる。という形で、\\(\\gamma_{AL}\\), \\(\\gamma_{AZ}\\) … \\(\\gamma_{WY}\\)のワイオミング州までを推定するのである。 実際には、これをfeolsでは簡単に推定できる。 # |のあとに固定効果として推定したいカテゴリ（今回は州なのでstate)を入れる reg1_panel_fe = feols(fatal_rate ~ beertax | state, data = data_f2) etable(reg1_panel, reg1_panel_fe, se = &quot;IID&quot;) ## reg1_panel reg1_panel_fe ## Dependent Var.: fatal_rate fatal_rate ## ## Constant 1.853*** (0.0436) ## beertax 0.3646*** (0.0622) -0.6559*** (0.1878) ## Fixed-Effects: ------------------ ------------------- ## state No Yes ## _______________ __________________ ___________________ ## S.E. type IID IID ## Observations 336 336 ## R2 0.09336 0.90501 ## Within R2 -- 0.04075 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 結果は、固定効果モデル（右）では単位回帰モデル（左）では正だった係数が負になっている。 この結果を解釈すると、「ビール税率が上がると、交通事故死亡率が下がる」という解釈となる。 このように、本当に推定したい効果が、データの特徴によって推定できない場合、それが主体独特の効果である場合は、固定効果モデルを用いることで分別して推定することができる。 しかし、固定効果モデルはパネルデータではないと使うことができない。 たとえば、上で作成したクロスセクションデータで固定効果モデルを推定してみよう。 reg1_panel_fe_1988 &lt;- feols(fatal_rate ~ beertax | state, data=data_f2_1988) ## Error: in feols(fatal_rate ~ beertax | state, data = data_f...: ## The only variable, &#39;beertax&#39;, is collinear with the fixed effects. Without doubt, your model is misspecified. エラーが出る。これは、クロスセクションデータでは州ごとの変動しかないため、ダミー変数による固定効果の変動（州によって1か0か）と州ごとのビール税の変動のどちらが交通事故死亡率の変動を説明しているか識別ができないためである。 13.3.1 固定効果モデルのビジュアルイメージ 固定効果モデルをビジュアルイメージで理解してみよう。 まず、パネルデータを使って散布図を書いてみよう。 ggplot(data=data_f2, aes(x=beertax,y=fatal_rate)) + geom_point(size=0.5) + labs(x = &quot;ビール税率&quot;, y=&quot;死亡率&quot;) + theme_bw(base_family = &quot;HirakakuPro-W3&quot;) これだけを見ると、やはり右肩上がりの傾向があるように見える。 geom_smooth(method=\"lm\")というレイヤーを加えて、回帰線を描いてみよう。 ggplot(data=data_f2, aes(x=beertax,y=fatal_rate)) + geom_point(size=0.5) + labs(x = &quot;ビール税率&quot;, y=&quot;死亡率&quot;) + geom_smooth(method=&quot;lm&quot;) + theme_bw(base_family = &quot;HirakakuPro-W3&quot;) やはり右肩あがりになっている。 では、今度は州ごとに色分けしてみよう。aes()の中で色カテゴリに州を指定するcol=state。 ggplot(data=data_f2, aes(x=beertax,y=fatal_rate,col=state)) + geom_point(size=0.5) + labs(x = &quot;ビール税率&quot;, y=&quot;死亡率&quot;) + geom_smooth(method=&quot;lm&quot;, se=FALSE) + theme_bw(base_family = &quot;HirakakuPro-W3&quot;) + theme(legend.position = &quot;none&quot;) # &lt;- もし凡例が大きすぎて図が見えない場合はこのレイヤーを追加して凡例を消す すると、州ごと分けた点と線が描かれる。州ごとに見ると、州の中での時間的な変動ではビール税率が高いときに死亡率が下がっている傾向が見られるだろう。このように、州間の違いと州内の違いを分けて推定できるのが固定効果モデルである。 "],["did.html", "Chapter 14 差の差法 14.1 差の差法とは 14.2 Rでの演習", " Chapter 14 差の差法 14.1 差の差法とは ここからは、より因果関係を推定できる可能性が高い疑似実験の手法を学んでいきます。 差の差法（Difference-in-Differences, DiD, 差分の差分法)は、文字通り2つのグループの差に差があるか、をみることであるグループに施行された政策や出来事の効果や影響を推定しようとするアプローチである。 14.1.1 差の差法のアイデア パネルデータで説明したような状況でもあっても、目的変数と説明変数の両方に影響を与える変数の存在を完全に排除しきれるわけではない。 パネルデータで紹介した固定効果モデルでも、固定効果を除いた説明変数の効果を推定できているが、固定効果ではない変数が存在している可能性も否定はできない。 より因果関係により迫れる方法として、疑似実験が挙げられる。これはあたかも実験のような状況を見つけ出して、実験でいう処置群（政策などの影響を受けるグループ）と、対照群（効果・影響を受けないグループ）を比較する方法である。 本当の実験であれば、処置を行う前はいずれのグループも全く同じであり、処置を受けた後に2つを比較すれば、その差が処置の効果だと言うことになる。 実際の社会では、政策などが実施される前後で2つのグループが全く同じ、ということはまれであろう。 しかし、2つのグループが異なるけれど、同じような動きをする、と考えればもう少し可能性は広がる。 例えば、埼玉県と東京都の平均所得は当然異なるが、景気などによって東京都の所得が上がっているときは埼玉県の所得も上がっていそうだ。 このように平行に推移する目的変数であるならば、差だけをとっても比較はできないが、差の差、を取ることで比較することが可能になる。 下の図は、差の差法の概念を示した図である。 knitr::include_graphics(&quot;fig/did_concept_pos.png&quot;) 処置群は、なんらかの政策を受ける。効果があるならば、政策によって目的変数が変化する。 しかし、前後関係だけで比較することはできない。なぜならば、その前後の変化は政策以外による影響もあるかもしれないからだ。 仮に、東京都の中学校で１クラス40人学級だったものを、30人学級に変更するという政策が行われたとしよう。 担任の教師ひとりが担当する生徒数が減るので、より目が行き届くようになり、生徒にとって良い影響があると期待される。 例えば、平均的な試験のスコアが上がると期待される。 この変更を実際に施行して東京都の中学校の試験の平均スコアを比較してみたとしよう。すると、図のように前回よりも下がっていたとしたらどうだろうか？ クラスの人数を少なくすることはよいことどころかスコアを悪化させる悪い政策だったのだろうか？ となりの埼玉県でも同じテストを実施しているとしよう。しかし、東京都と違って埼玉県ではこの時期にクラス人数の変更やその他テストスコアに影響しそうな施策を変更していないとする。この埼玉県の中学校を比較対象グループとする。 埼玉県のテストスコアを見てみると、大きく減少している。例えば、たまたま学級サイズ変更後のテストが前年のテストより難しかった可能性がある。 埼玉県と東京都は東京都のほうが上だが、普段は同じような動きをするとする（平行トレンドの家庭）。 そこで、埼玉県の「前後の差」を東京都の「もし学級サイズの変更がなかった場合の差」として考えてみる。 すると、東京都はもし学級サイズの変更がなければ図の点線のような動きになっていたことになる。すなわち、もっとテストスコアが悪かっただろう、ということだ。 そこで、「実際に観察された東京都の前後差」を埼玉県の前後差から引くと、「東京都がもし学級サイズを変更していなかった場合のテストスコアの差」から「東京都が学級サイズを変更した場合（つまり現実）のテストスコアの差」を引くことと同義になり、東京都で学級サイズを変更したことによるテストスコアへの影響を推定できることになる。 これが差の差法のアイデアである。 14.1.2 差の差法の仮定 因果推定としての差の差法による推定では、以下のような仮定を置いて推定する。以下の仮定が明らかに成り立たない場合は、この方法は使えないことに留意が必要だ。 平行トレンドの仮定：処置グループと対照グループはもし政策の施行がなければ平行に推移する。 スピルオーバーがない：処置グループの効果や影響が対照グループに影響しない。 14.1.3 回帰分析を使って行う方法 比較するというアイデアは上の通りだが、それを実際にどうやって推定するのだろうか？ ここでは、回帰分析を使って差の差法を推定する方法を説明する。 差の差法が適用できるようなデータは、少なくとも2つの期間（政策施行前と後）があり、2つのグループ（政策が施行されたグループと対照グループ）がある。 データでは、それぞれ個々人や自治体などのユニットで値は異なるが、簡単に説明するためにそれぞれのグループの平均だけで話をすると、以下のように整理できる。 対照群 (A) 処置群 (B) 時点 t=1 \\(Y_{1A}\\) \\(Y_{1B}\\) 時点 t=2 \\(Y_{2A}\\) \\(Y_{2B}\\) ここで、処置群の差は\\(Y_{2B} - Y_{1B}\\)で表され、対照群の差は\\(Y_{2A} - Y_{1A}\\)となる。 差の差で推定される効果は \\[ (Y_{2B} - Y_{1B}) - (Y_{2A} - Y_{1A}) \\] として表現することができる。平均値だけで言えば、これで推定された値が差の差法で推定された政策の効果である。 これを回帰分析で表現するとどうなるだろうか。 政策前後と対照・処置群両方が含まれたデータを使って、以下のような式を推定するとする。 \\[ Y_{it} = \\alpha + \\beta_{1} Policy_{i} + \\beta_{2} Time_{t} + \\beta_{3} Policy_{i} \\times Time_{t} + \\varepsilon_{it} \\] ここで、\\(Policy_{i}\\)と\\(Time_{t}\\)はダミー変数である。\\(Policy_{i}\\)はもし、該当データ（個人\\(i\\)）が、処置群に入るならば１、対照群ならば０を取る。 \\(Time_{t}\\)は該当データ(時点\\(t\\))のタイミングが政策実施後ならば１，政策実施前ならば0を取る。 それぞれのケースを見てみよう。 ケース１：政策実施前＋対照群 もし政策実施前で、対照群に入っているデータならば \\[ Y_{it} = \\alpha + \\beta_{1} 0 + \\beta_{2} 0 + \\beta_{3} 0 \\times 0 + \\varepsilon_{it} = \\alpha + \\varepsilon_{it} \\] このケースは、上の表でいうと\\(Y_{1A}\\)に当たる。このグループの平均を取ると、誤差項はゼロになるので、\\(Y_{1A} = \\alpha\\)となる。 ケース２：政策実施前＋処置群 もし政策実施前(\\(Time_{t} = 0\\))で、処置群(\\(Policy_{i}=1\\))に入っているデータならば \\[ Y_{it} = \\alpha + \\beta_{1} 1 + \\beta_{2} 0 + \\beta_{3} 1 \\times 0 + \\varepsilon_{it} = \\alpha + \\beta_{1} + \\varepsilon_{it} \\] 同様に\\(Y_{1B}=\\alpha + \\beta_1\\)となる。 ケース３：政策実施後＋対照群 もし政策実施後(\\(Time_{t} = 1\\))で、対照群(\\(Policy_{i}=0\\))に入っているデータならば \\[ Y_{it} = \\alpha + \\beta_{1} \\cdot0 + \\beta_{2} \\cdot 1 + \\beta_{3} \\cdot 0 \\times 1 + \\varepsilon_{it} = \\alpha + \\beta_{2} + \\varepsilon_{it} \\] 同様に\\(Y_{2A}=\\alpha + \\beta_2\\)となる。 ケース４：政策実施後＋処置群 もし政策実施後(\\(Time_{t} = 1\\))で、対照群(\\(Policy_{i}=0\\))に入っているデータならば \\[ Y_{it} = \\alpha + \\beta_{1} \\cdot 1 + \\beta_{2} \\cdot 1 + \\beta_{3} \\cdot 1 \\times 1 + \\varepsilon_{it} = \\alpha + \\beta_{1} + \\beta_{2} + \\beta_{3} + \\varepsilon_{it} \\] 同様に\\(Y_2B=\\alpha + \\beta_1 + \\beta_2 \\beta_3\\)となる。 14.1.4 演習問題：差の差法の回帰分析アプローチ 差の差法による推定効果が、回帰式の\\(\\beta_{3}\\)と一致することを証明してみよう。 14.2 Rでの演習 14.2.1 スクリプトの準備 新しいスクリプトにコードを書いていく。 新しくスクリプトを作成し、did.Rという名前をつけて保存する。 14.2.2 パッケージの準備 以下のパッケージを使うので読み込んでおく。 インストールしてない場合は、インストールする。 # ライブラリ library(tidyverse) library(skimr) library(fixest) 14.2.3 データの準備 データをダウンロードする。 # データのダウンロードとdataフォルダへの格納を自動的に行う download.file(&quot;https://github.com/keita43a/regression_tutorial/blob/main/data/data_njmin.csv?raw=TRUE&quot;, destfile = &quot;data/data_njmin.csv&quot;) # データを読み込む data_njmin = read_csv(&quot;data/data_njmin.csv&quot;) 14.2.4 データの確認 このデータはアメリカの２つの州におけるファーストフード店の雇用者数や賃金が記録されている。 州のPAはペンシルベニア州、NJはニュージャージー州である。 このデータは差の差分析でもっとも有名な論文であるCard and Krueger (1994)で実際に用いられたデータである。 1992年にニュージャージ州では最低賃金が引き上げられた（$4.25 -&gt;$5.05)が、隣のペンシルベニア州ではそのような政策の変更がなかった。 この現象を利用して、差の差分析を用いて最低賃金が雇用に影響をもたらすかどうかを分析した研究である。 データの中身を見てみる。 まずは、どんなデータなのかhead()で確認する。 head(data_njmin) ## # A tibble: 6 × 9 ## state fulltime_before parttime_before wage_before fulltime_after parttime_after wage_after full_prop_before full_prop_after ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 PA 20 20 5 0 36 5.25 0.5 0 ## 2 PA 6 26 5.5 28 3 4.75 0.188 0.903 ## 3 PA 50 35 5 15 18 4.75 0.588 0.455 ## 4 PA 10 17 5 26 9 5 0.370 0.743 ## 5 PA 2 8 5.25 3 12 5 0.2 0.2 ## 6 PA 2 10 5 2 9 5 0.167 0.182 14.2.5 データの記述統計 データの記述統計を確認しよう。 Chapter @ref(#rstats) で説明したように、ここではskimrパッケージのskim()関数を使った。 library(skimr) skim(data_njmin) Table 14.1: Data summary Name data_njmin Number of rows 358 Number of columns 9 _______________________ Column type frequency: character 1 numeric 8 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace state 0 1 2 2 0 2 0 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist fulltime_before 0 1 8.47 8.70 0.00 2.12 6.00 12.00 60.00 ▇▂▁▁▁ parttime_before 0 1 18.75 10.29 0.00 11.00 16.25 25.00 60.00 ▆▇▅▁▁ wage_before 0 1 4.62 0.35 4.25 4.25 4.50 4.99 5.75 ▇▃▃▁▁ fulltime_after 0 1 8.36 7.81 0.00 2.00 6.00 12.00 40.00 ▇▃▁▁▁ parttime_after 0 1 18.69 10.57 0.00 11.00 17.00 25.00 60.00 ▆▇▅▁▁ wage_after 0 1 4.99 0.26 4.25 5.05 5.05 5.05 6.25 ▁▇▁▁▁ full_prop_before 0 1 0.30 0.23 0.00 0.11 0.26 0.47 1.00 ▇▆▃▂▁ full_prop_after 0 1 0.31 0.25 0.00 0.11 0.27 0.50 1.00 ▇▅▃▂▁ 14.2.6 政策変更の確認 ここでは、実際に政策変更が行われたかを2 x 2 の表を作成することで確認しよう。 上の表のように、２ｘ２の表では以下のような形となることを理解しよう。 ここでは目的変数（雇用）ではなく、処置を受けた場合に変化する変数（最低賃金）であることに注意しよう。 賃金(wage)なので\\(w\\)で表記する。 対照群 (PA) 処置群 (NJ) 時点 t=1 \\(w_{1,PA}\\) \\(w_{1,NJ}\\) 時点 t=2 \\(w_{2,PA}\\) \\(w_{2,NJ}\\) グループごとの記述統計（セクション6.11.12参照）を用いて、上のような表を作ってみよう。 njmin_table &lt;- data_njmin |&gt; group_by(state) |&gt; # 州ごとにグループ分けを行う summarise(before = mean(wage_before), after = mean(wage_after), .groups = &quot;drop&quot;) # 混乱を避けるためgroup_byで指定したグループ化を解除 njmin_table ## # A tibble: 2 × 3 ## state before after ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NJ 4.61 5.08 ## 2 PA 4.65 4.61 上の表と違って、行に州が、列に時期が入ってしまっているが、計算したいことはできている。 予想通り、ペンシルベニア州（PA）では、政策変更の前後ともにあまり平均賃金は変わっていないが、ニュージャージ州（NJ）では変更後に平均賃金が上がっている。 当然ながら、平均賃金は新しい最低賃金（$5.05)よりも高い。 14.2.6.1 演習問題：処置に反応しているかの確認 本当にペンシルベニア州のファーストフード店が最低賃金の引き上げに従っているのだろうか？ 政策施行の前後と州ごとに、賃金が5.05 (PAの政策施行後の最低賃金)より低い店の割合を計算し、njmin_table2というオブジェクトに格納してから表示しなさい。 ヒント：もしwage_before &lt; 5.05という命題が論理値によって評価される場合はTRUEかFALSEが返されるが、TRUEは1, FALSEは0として評価される。 そのためmean(wage_before &lt; 5.05)という計算によって、1と0の平均が計算されるということは、wage_before &lt; 5.05である割合を計算することと同義である。 ## # A tibble: 2 × 3 ## state before after ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NJ 0.911 0.00344 ## 2 PA 0.940 0.955 結果は上のような表が出力される。 ニュージャージ州の政策施行後だけ、著しく低い割合になっている。すべての店ではないが、多くの店は最低賃金のルールに従って賃金を設定しているようだ。 14.2.6.2 演習問題：前後での比較 よく行われる比較は、実際に政策を実行してみた後とその前を比較して「上がったか？下がったか？」を議論するやり方だ。 ニュースなどでも「〇〇を実施した後、△△がX%上昇」などという文言を聞くことがあるだろう。 ここでは、前後比較を計算してみよう。 ニュージャージー州のみのデータを抽出しなさい フルタイム労働者の割合(full_prop_**)の平均をそれぞれ政策施行前、後でとりなさい。 full_prop_diffという列を作成し、計算した前後の平均の差を計算しなさい。 njmin_table3というオブジェクトに格納して、コンソールに表示しなさい ## # A tibble: 1 × 3 ## full_prop_before full_prop_after full_prop_diff ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.297 0.320 0.0239 上のような表が表示される。 前後の差は0.0238…なので2.4%ポイント上昇したことになる。これは正しい推定だろうか？ 当然前後の比較なので、この比較は「もし政策が変わらなければ、NJ州のフルタイム雇用率は政策実施前から変わらない」ことが仮定として暗に置かれている。 しかし、経済状況など様々な他の要因は変わりうる。この前後比較というのは、実はかなり強い仮定（=あまり現実的ではない仮定）のもとで推定されているに過ぎないのである。 14.2.7 差の差法 各グループと前後の平均だけで推定する方法で差の差法を推定してみよう。 まず2x2の目的変数の2x2の表を作成する。 対照群 (PA) 処置群 (NJ) 時点 t=1 \\(Y_{1,PA}\\) \\(Y_{1,NJ}\\) 時点 t=2 \\(Y_{2,PA}\\) \\(Y_{2,NJ}\\) njmin_table_did &lt;- data_njmin |&gt; group_by(state) |&gt; summarize(full_prop_before = mean(full_prop_before), full_prop_after = mean(full_prop_after), .groups = &quot;drop&quot;) njmin_table_did ## # A tibble: 2 × 3 ## state full_prop_before full_prop_after ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NJ 0.297 0.320 ## 2 PA 0.310 0.272 さらに上のコードに付け足して、差の差を計算する。 njmin_table_did2 &lt;- data_njmin |&gt; group_by(state) |&gt; summarize(full_prop_before = mean(full_prop_before), full_prop_after = mean(full_prop_after), .groups = &quot;drop&quot;) |&gt; mutate(full_prop_diff = full_prop_after - full_prop_before) |&gt; with(full_prop_diff[state==&quot;NJ&quot;] - full_prop_diff[state==&quot;PA&quot;]) njmin_table_did2 ## [1] 0.06155831 つまり、6.15%ポイント雇用が増加したという推定になる。 14.2.8 回帰分析による差の差法 上で解説した回帰分析による差の差法の推定を行ってみよう。 まず、データをlong形式に変換し、同じ変数であるフルタイム雇用の割合を前後で一つの列にする。 data_njmin_long &lt;- data_njmin %&gt;% # 州とfull_で始まる列のみ抽出 dplyr::select(state, starts_with(&quot;full_&quot;)) %&gt;% # fullで始まる列を選択して、カテゴリ名をtiming, 数値の列名をpropとしてlong形式にする pivot_longer(cols = starts_with(&quot;full&quot;), names_to = &quot;timing&quot;, names_prefix = &quot;full_prop_&quot;, values_to = &quot;prop&quot;) %&gt;% # 新たなダミー変数を作成する。上と同様に、policyは政策を受ける（最低賃金が上げられる）州なら１とするダミー変数 # timeは政策の前後で後ならば1とするダミー変数 mutate(policy = ifelse(state == &quot;NJ&quot;, 1, 0), time = ifelse(timing == &quot;after&quot;, 1, 0)) このlong形式のデータセットを使って回帰分析を行う。 Rの回帰式では、policyとtimeの交差項はpolicy:timeとコロン(:)でつなぐことで表現する。 掛け算なのでpolicy*timeと思うかもしれないが、アスタリスク*でつなぐと、policyとtimeそれぞれも再度含めてしまう。 （すなわちpolicy*timeはpolicy + time + policy:timeと同義である。ここではあえて省略せずに後者で書くことで、回帰式と一致していることを確認している。） reg_did1 &lt;- feols(prop ~ policy + time + policy:time, data=data_njmin_long) etable(reg_did1) ## reg_did1 ## Dependent Var.: prop ## ## Constant 0.3100*** (0.0295) ## policy -0.0134 (0.0327) ## time -0.0377 (0.0417) ## policy x time 0.0616 (0.0463) ## _______________ __________________ ## S.E. type IID ## Observations 716 ## R2 0.00392 ## Adj. R2 -0.00028 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 回帰分析表のpolicy x timeの推定値は0.0616となっているが、これは上で計算した差の差法の推定値と同じである。 ただし、統計的には母集団ではゼロである仮説を棄却できないため、増加するとは言い難いが、 少なくとも減少はしていない。 この研究は、差の差法を使って最低賃金の雇用に対する影響という経済学において重要な問いに答えた有名な研究であり、それまでは最低賃金を上げると雇用に対して悪影響が起こるとされていた理論に対して新たな貢献をした重要な研究である。 "],["rdd.html", "Chapter 15 回帰不連続デザイン 15.1 回帰不連続デザインとは 15.2 Rでの演習 15.3 演習問題：アメリカの飲酒年齢と死亡率", " Chapter 15 回帰不連続デザイン 15.1 回帰不連続デザインとは 回帰不連続デザイン(Regression Discontinuity Design, RDD)も、回帰不連続デザインと同様疑似実験を用いた手法の一つである。 連続的に変化すると考えられるある変数が、政策介入や処置によって急激な変化（ジャンプ）する場合に、その急激な変化を介入や処置による効果として推定する手法である。 15.1.1 回帰不連続デザインのアイデア お酒・アルコールを飲むのは（好きな人には）楽しいですが、当然負の側面もある。健康被害を起こしたり、また事故なども起こる可能性がある。 アルコールを接種することで、死亡率は上がるのだろうか。 アルコールを接種するかどうかは、法律によって年齢が決まっている。「お酒は二十歳になってから」と言われるように、日本では飲酒の年齢は20歳からである。 つまり、18歳や19歳ならばお酒は飲まないが、20歳以上ならば飲酒するという傾向があるのである。（当然ならば法律を守っているかどうか、という議論はあるが、すくなくても法律を守っていないのは一部で多くは20歳から飲酒するだろう） しかし、18〜22歳ぐらいまでの若者は基本的には似た性質を持っていると考えられる。20歳になって、いきなり死亡率が増えるとは考えにくい。そのため、18歳や19歳に比べて、20歳や21歳で突然死亡率が上がっているならば、それは20歳をカットオフ（閾値）として扱い（処置）が変わる飲酒傾向によるものと考えることができるだろう。 18-19歳の人々は「対照群」、20-22歳の人を「処置群」として考えることができ、比較が可能となる。これが、基本的な回帰不連続デザインのアイデアである。 年齢によって死亡率は異なるが、少なくともその変化は滑らかであると考えられる。そこで、境界線上に大きな変化（ジャンプ）が起こっていれば、それが政策や処置の効果であると考えて推定を行うのである。 ここでは、年齢のような変数を割当変数と呼ぶ。 15.1.2 回帰不連続デザインの仮定 割当変数と目的変数の間には政策がなければ滑らかに変化する関係がある カットオフ前後では政策以外に大きな相違がなくほぼ同じである カットオフの存在によって、割当変数を操作するようなことがない 例：奨学金がもらえるカットオフが80点だとする。そこがカットオフだと知っていれば、80点にギリギリみたないような人がいつも以上に頑張って80点以上を取ろうとする。これは、政策（奨学金給付）があることで、政策がなければないようなカットオフ間の移動が起こっているため、仮定を満たさない。 15.1.3 回帰分析を使って行う方法 回帰不連続デザインを回帰分析で行う場合は、式としていくつかの方法があるが、ここでは比較グループと政策実施グループで異なる傾きを持つ分割線形回帰を紹介する。 まず回帰式は以下のようになる。 \\[ Y_{i} = \\alpha + \\rho Policy_{i} + \\beta_{1} x_{i} + \\beta_{2} Policy_{i} \\times x_{i} + \\varepsilon_{i} \\] ここで、\\(Policy_{i}\\)はダミー変数である。\\(Policy_{i}\\)はもし、該当データが、割当変数でカットオフより大きい（政策によっては小さい）個人\\(i\\)が、処置群に入るならば１、対照群ならば０を取る。 例えば、飲酒年齢の問題では年齢が割当変数(\\(x_i\\))となる。そして、20歳以上ならば、\\(Policy_{i}\\)は1となるが、20歳未満は\\(Policy_{i}\\)が0となる。 ここでは、因果効果として推定されるパラメータは\\(\\rho\\)（ローと読む）である。 上の概念図に対応させると、以下のようになる。 左右の直線は、政策が適用される側（処置群）とされない側（対照群）でデータに基づいてそれぞれ推定された回帰直線である。 もし仮に、推定された結果について\\(\\beta_2\\)と\\(\\rho\\)がゼロだとする。すると、回帰式は \\[ Y_{i} = \\alpha + \\beta_{1} x_{i} + \\varepsilon_{i} \\] となり、単なる単回帰式となる。図で表すと以下のような形だ。 この場合は、当然ながら政策によって割当変数と目的変数のスムーズな関係に変化は起こっていない。 もし\\(\\beta_2\\)がマイナスの値で、\\(\\rho\\)がゼロだったらどうなるか。 この場合は以下のような式になる。 \\[ Y_{i} = \\alpha + \\beta_{1} x_{i} + \\beta_{2} Policy_{i}\\times x_{i} + \\varepsilon_{i} \\] この場合の\\(x_i\\)の係数は、\\(\\beta_{1} x_{i} + \\beta_{2} Policy_{i}\\times x_{i} = (\\beta_{i} + \\beta_{2} Policy_{i})x_{i}\\)と解釈することができる。つまり、カットオフより下ならば\\(Policy_{i}=0\\)なので、係数は\\(\\beta_{1}\\)になるが、カットオフより上ならば\\(Policy_{i}=1\\)なので、係数は\\(\\beta_{1} + \\beta_{2}\\)となる。 もし政策効果がないならば、左右の直線はつながった形になる。もし政策がなければ、目的変数は割当変数に従って滑らかに変化する。もしかしたら比例関係ではなく、どこかで傾向が変わる関係かもしれない。そのために\\(\\beta_2\\)を推定して、傾向が変わることを許すモデルにしているのである。仮にそのような関係があったとしても、「ジャンプ」がない限りは政策効果はないと考えられる。 政策効果\\(\\rho\\)がゼロでない場合のみ、2つの直線の間に「ジャンプ」が生じる。これが政策が行われたことによる効果であると解釈される。 15.2 Rでの演習 15.2.1 スクリプトの準備 新しいスクリプトにコードを書いていく。 新しくスクリプトを作成し、rdd.Rという名前をつけて保存する。 15.2.2 パッケージの準備 以下のパッケージを使うので読み込んでおく。 インストールしてない場合は、インストールする。 # ライブラリ library(tidyverse) library(skimr) library(fixest) 15.2.3 データの準備 データをダウンロードする。 # データのダウンロードとdataフォルダへの格納を自動的に行う download.file(&quot;https://github.com/keita43a/regression_tutorial/blob/main/data/data_rdd.csv?raw=TRUE&quot;, destfile = &quot;data/data_rdd.csv&quot;) # データを読み込む data_rdd = read_csv(&quot;data/data_rdd.csv&quot;) 15.2.4 データの確認 このデータは生成されたデータであるが、実際の研究に使われたデータを模倣したものである。 Shigeoka (2014)では、日本の医療費の自己負担割合が70歳を境に3割から1割に下がることに着目し、この自己負担割合の変化が高齢者の死亡率を下げることに貢献しているかどうかを検証した。もし、自己負担割合が下がることで高齢者が病気や怪我のときに病院に行くようになり、それが結果として死亡率の低下に貢献しているのならばこの政策は一定の効果があると言える。 回帰不連続デザインを使う理由は70歳というカットオフが存在するからである。69歳11ヶ月の人は自己負担割合が3割だが、70歳0ヶ月になると突然1割になる。しかし、70歳になったからといって突然不健康になったり死亡率が上がるわけではないため、70歳になって急激に死亡率が下がっているのならば、これは自己負担割合の違いが死亡率の低下に貢献していると言えるというわけだ。 データの中身を見てみる。 まずは、どんなデータなのかhead()で確認する。 head(data_rdd) ## # A tibble: 6 × 3 ## age visits death ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 65.1 -0.0922 -0.281 ## 2 65.2 -0.0794 -0.298 ## 3 65.2 -0.115 -0.286 ## 4 65.3 -0.0603 -0.282 ## 5 65.3 -0.121 -0.286 ## 6 65.5 -0.00707 -0.281 15.2.5 データの記述統計 データの記述統計を確認しよう。 Chapter @ref(#rstats) で説明したように、ここではskimrパッケージのskim()関数を使った。 library(skimr) skim(data_rdd) Table 15.1: Data summary Name data_rdd Number of rows 100 Number of columns 3 _______________________ Column type frequency: numeric 3 ________________________ Group variables None Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist age 0 1 69.85 3.02 65.10 67.19 69.94 72.50 74.93 ▇▆▇▅▇ visits 0 1 -0.03 0.08 -0.18 -0.10 -0.03 0.03 0.13 ▃▇▆▅▃ death 0 1 -0.01 0.18 -0.30 -0.17 -0.01 0.15 0.30 ▇▆▆▆▇ 15.2.6 データの加工 データには年齢は記録されているが、70歳以上かどうかを示す情報は直接は記録されていない。 年齢から、70歳以上かどうか、というダミー変数を作成しよう。 ifelse(test,true,false)という関数は1つ目の引数であるtestに条件式を入れる。その条件式を評価して、真であれば2つ目の引数であるtrueに入力された値を返す。偽であればfalseである3つ目の引数の値を返す。この場合はage &gt;= 70が条件式なので、各行においてageが70以上であれば、1を入れ、そうでなければ0を入れる。 data_rdd &lt;- data_rdd |&gt; mutate(dummy70 = ifelse(age &gt;= 70, 1, 0)) 15.2.7 政策による行動への影響 ここでは、政策によって実際に行動が変わっているかをまず確認する。 下のコードでは、aes()によるマッピングの中に、groupという項目が入っている。これは、描画に使うデータを年齢が70歳以上か未満かdummy70で分ける機能を持つ。 こうすることで、geom_smoothを使うときに、70歳未満と以上で別々の直線を描いてくれる。 geom_vlineは縦(vertical)の直線を追加するレイヤーである。この場合は、x軸上の70歳(xintercept = 70)に縦の直線を、線の種類をダッシュ(linetype=\"dashed\")で、色を赤で(color=\"red\")追加する。 ggplot(data_rdd, aes(x = age, y = visits, group = dummy70)) + geom_point(color = &#39;gray&#39;) + geom_smooth(method = &#39;lm&#39;, color = &#39;black&#39;, se = FALSE) + geom_vline(xintercept = 70, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs(x = &quot;年齢&quot;, y = &quot;外来患者数(対数)&quot;, title = &quot;自己負担割合が減ると外来受診が増える&quot;) + theme_minimal(base_family=&quot;HiraKakuPro-W3&quot;) これを見ると、外来患者数には70歳を境に大きなジャンプがある。 つまり、自己負担割合が低くなることで、外来患者の数が急激に増加している。 このことから、自己負担割合の変化は外来診察を受けるインセンティブを高め、高齢患者の行動を変えていると言えそうだ。 15.2.7.1 回帰分析による推定 回帰分析でこの効果を推定してみよう。 この場合は \\[ Visits_{i} = \\alpha + \\rho Dummy70_{i} + \\beta_{1}age_{i} + \\beta_{2} age_{i}\\times Dummy70_{i} + \\varepsilon_{i} \\] という式を推定することになる。 rdd_visit &lt;- feols(visits ~ dummy70 + age + dummy70:age, data=data_rdd) etable(rdd_visit) ## rdd_visit ## Dependent Var.: visits ## ## Constant -0.5376. (0.2933) ## dummy70 1.789*** (0.4178) ## age 0.0066 (0.0044) ## dummy70 x age -0.0233*** (0.0060) ## _______________ ___________________ ## S.E. type IID ## Observations 100 ## R2 0.72216 ## Adj. R2 0.71348 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 結果は\\(\\rho\\)が1.789と推定された。\\(Visits\\)は対数で表示されているため、このジャンプによって訪問患者数が179%増加したという結果になる。 繰り返しになるが、これは元の研究を模倣したデータであり、説明のために大きく省略したアプローチを取っているのでオリジナルの研究とこの数字は一致しない。 15.2.8 政策による結果への影響 今度は、政策によって重要な結果、ここでは死亡率に効果があるかを見てみよう。 ggplot(data_rdd, aes(x = age, y = death, group = dummy70)) + geom_point(color = &#39;gray&#39;) + geom_smooth(method = &#39;lm&#39;, color = &#39;black&#39;, se = FALSE) + geom_vline(xintercept = 70, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs(x = &quot;年齢&quot;, y = &quot;死亡率(対数)&quot;, title = &quot;自己負担割合が減っても死亡率は変わらない&quot;) + theme_minimal(base_family=&quot;HiraKakuPro-W3&quot;) 上と同様に分割して回帰直線を描いているが、あたかもつながっているかのような直線になっている。大きなジャンプは見られず、70歳になって突然死亡率が下がったという傾向はなさそうである。 15.2.8.1 回帰分析による推定 回帰分析でこの効果を推定してみよう。 この場合は \\[ Death_{i} = \\alpha + \\rho Dummy70_{i} + \\beta_{1}age_{i} + \\beta_{2} age_{i}\\times Dummy70_{i} + \\varepsilon_{i} \\] という式を推定することになる。 rdd_death &lt;- feols(death ~ dummy70 + age + dummy70:age, data=data_rdd) etable(rdd_death) ## rdd_death ## Dependent Var.: death ## ## Constant -4.283*** (0.0680) ## dummy70 0.1488 (0.0969) ## age 0.0612*** (0.0010) ## dummy70 x age -0.0021 (0.0014) ## _______________ __________________ ## S.E. type IID ## Observations 100 ## R2 0.99693 ## Adj. R2 0.99683 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 結果は\\(\\rho\\)が0.1488と推定された。また、統計的に有意ではないため、0であるという仮説を棄却できない。 このことから、死亡率に対する健康保険の自己負担割合の低下は効果を与えていないという結論が導かれる。 15.3 演習問題：アメリカの飲酒年齢と死亡率 以下のコードを実行してデータをダウンロードして読み込む。 # データのダウンロードとdataフォルダへの格納を自動的に行う download.file(&quot;https://github.com/keita43a/regression_tutorial/blob/main/data/data_alcohol.csv?raw=TRUE&quot;, destfile = &quot;data/data_alcohol.csv&quot;) # データを読み込む data_alcohol= read_csv(&quot;data/data_alcohol.csv&quot;) これはアメリカの誕生日によって区切られた年齢グループ別のデータである。約一ヶ月ごとに誕生日からどれぐらい経っているか（例：20歳の誕生日から1ヶ月以上2ヶ月未満）などのグループ(agecell)で区切られている。またそのグループ別に、死因別や合計(all_death)の死亡数が記録されている。 データの記述統計を確認する。 agecellを割当変数、policyを政策変数、all_deathを目的変数として回帰不連続デザインの図を描きなさい。アメリカの飲酒年齢は21歳である。 以下のモデルを推定して、結果をコンソールに表示する。ageはagecellを21歳を中心として基準化した変数である。（例えば19歳はageでは-2となる。） \\[ all\\_death_{it} = \\alpha + \\rho Policy_{i} + \\beta_{1} age_{t} + \\beta_{2} Policy_{i} \\times age_{t} + \\varepsilon_{it} \\] 結果を解釈する。 "],["practiceanswer.html", "Chapter 16 練習問題解答 16.1 Ch.4 16.2 Ch. 6 16.3 Ch. 8 16.4 Ch 10", " Chapter 16 練習問題解答 16.1 Ch.4 練習問題 4.1.4 # 1 9179/67 ## [1] 137 # 2 (256*43+54)/8 ## [1] 1382.75 # 3 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 ## [1] 78 練習問題 4.2.3 # まずgoukeiに0を入れる goukei &lt;- 0 for(i in 1:50){ goukei &lt;- goukei + i } print(goukei) ## [1] 1275 練習問題 4.4.3 # 3から60まで3ずつ増える数列 v7_ex &lt;- seq(3,60,by=3) print(v7_ex) ## [1] 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 練習問題 @ref(#vectormake2) v9_ex &lt;- rep(seq(2,10,by=2), 5) # パイプを使って以下のように書くこともできる(パイプは第6章を参照) v9_ex &lt;- seq(2,10,by=2) |&gt; rep(5) 16.2 Ch. 6 練習問題 @ref{datamgtpractice} 武蔵大学経済学部の学生数データを使って、女性のみの合計学生数を学年別で計算せよ。data_634_long_1_2_gradeというオブジェクトに格納し、同様に結果を表示せよ。 ## 女性のみの学年ごとの学生数 data_634_long_female_grade &lt;- data_634_long |&gt; filter(性別==&quot;女&quot;) |&gt; group_by(学年) |&gt; summarise(学生数合計 = sum(学生数)) print(data_634_long_female_grade) ## # A tibble: 4 × 2 ## 学年 学生数合計 ## &lt;chr&gt; &lt;dbl&gt; ## 1 1年 136 ## 2 2年 132 ## 3 3年 141 ## 4 4年 114 同じデータを使って、１,２年生のみ合計学生数を男女別・学年別で計算せよ。 ## 女性のみの学年ごとの学生数 data_634_long_1_2_grade &lt;- data_634_long |&gt; filter(学年==&quot;1年&quot; | 学年 == &quot;2年&quot;) |&gt; #数字が半角か、などに気をつける group_by(性別, 学年) |&gt; ## ２つのカテゴリでグループ分け summarise(学生数合計 = sum(学生数)) print(data_634_long_1_2_grade) ## # A tibble: 4 × 3 ## # Groups: 性別 [2] ## 性別 学年 学生数合計 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 女 1年 136 ## 2 女 2年 132 ## 3 男 1年 355 ## 4 男 2年 350 16.3 Ch. 8 練習問題8.17.1：散布図 plot_scatter &lt;- ggplot(data=diamonds) + geom_point(aes(x=carat,y=price, color=color)) print(plot_scatter) 練習問題8.18：折れ線グラフ plot_line &lt;- ggplot(data=economics) + geom_line(aes(x=date,y=unemploy)) print(plot_line) 16.4 Ch 10 AERパッケージを読み込む。インストールしていない場合はインストールする。 library(AER) # もしインストールしてない場合は、Rstudioの右下ペーンのPackagesタブからインストールするか、以下のコード install.packages(&quot;AER&quot;) data()関数を使って、CASchoolsというAERパッケージに付属しているデータを読み込む。これは、カリフォルニア州の学校ごとの学生数などのデータである。 data(&quot;CASchools&quot;) tidyverseパッケージの関数を使って、学生数studentsと教員数teachersの比を計算し、STRという変数にする。また、国語readと数学mathを足して２で割ったスコアをscoreという変数にする。新たに作成したデータをdat_schoolとして保存する。 dat_school &lt;- CASchools |&gt; mutate(STR = students/teachers, score = (read+math)/2) これがわからない場合は@ref{datamgcolumnadd}参照。 ggplotを用いて、x軸をSTR, y軸をscoreとする散布図を描く。以下のような図になるはずである（背景色やラベルなどは同じでなくてよい） ggplot(data=dat_school, aes(x=STR, y=score)) + geom_point() + theme_bw() STRを説明変数、scoreを目的変数とする単回帰分析を行い、summary()関数を用いて結果を表示しなさい。 # chapter 10のexerciseなのでreg_ex10というオブジェクト名にしたが、オブジェクト名はなんでもよい。 reg_ex10 &lt;- lm(score ~ STR, data=dat_school) summary(reg_ex10) ## ## Call: ## lm(formula = score ~ STR, data = dat_school) ## ## Residuals: ## Min 1Q Median 3Q Max ## -47.727 -14.251 0.483 12.822 48.540 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 698.9329 9.4675 73.825 &lt; 0.0000000000000002 *** ## STR -2.2798 0.4798 -4.751 0.00000278 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 18.58 on 418 degrees of freedom ## Multiple R-squared: 0.05124, Adjusted R-squared: 0.04897 ## F-statistic: 22.58 on 1 and 418 DF, p-value: 0.000002783 5.の結果を解釈しなさい。 学生-教員比が1上がるごとに、国語と数学の平均スコアは-2.28点下がる。 すなわち、教員に対する学生が多い学校では学生のテストスコアは低くなる傾向があるようである。 "],["graphreview2024.html", "Chapter 17 描画課題のレビュー 17.1 Yuma Ikeda 17.2 Yugo Kaneko 17.3 Yui Kunimatsu 17.4 Kotaro Mezaki 17.5 Rei Shimizu 17.6 Yuta Shimizu 17.7 Hyuga Yamanouchi 17.8 Jinto Eguro 17.9 描画テクニックの補足", " Chapter 17 描画課題のレビュー 17.1 Yuma Ikeda 17.1.1 オリジナルコード library(tidyverse) library(readxl) library(readr) data_ssdse&lt;-read_csv(&quot;data/SSDSE-B-2024.csv&quot;,locale=locale(encoding=&quot;cp932&quot;),skip=1) names(data_ssdse) ## [1] &quot;年度&quot; &quot;地域コード&quot; &quot;都道府県&quot; ## [4] &quot;総人口&quot; &quot;総人口（男）&quot; &quot;総人口（女）&quot; ## [7] &quot;日本人人口&quot; &quot;日本人人口（男）&quot; &quot;日本人人口（女）&quot; ## [10] &quot;15歳未満人口&quot; &quot;15歳未満人口（男）&quot; &quot;15歳未満人口（女）&quot; ## [13] &quot;15〜64歳人口&quot; &quot;15〜64歳人口（男）&quot; &quot;15〜64歳人口（女）&quot; ## [16] &quot;65歳以上人口&quot; &quot;65歳以上人口（男）&quot; &quot;65歳以上人口（女）&quot; ## [19] &quot;出生数&quot; &quot;出生数（男）&quot; &quot;出生数（女）&quot; ## [22] &quot;合計特殊出生率&quot; &quot;死亡数&quot; &quot;死亡数（男）&quot; ## [25] &quot;死亡数（女）&quot; &quot;転入者数（日本人移動者）&quot; &quot;転入者数（日本人移動者）（男）&quot; ## [28] &quot;転入者数（日本人移動者）（女）&quot; &quot;転出者数（日本人移動者）&quot; &quot;転出者数（日本人移動者）（男）&quot; ## [31] &quot;転出者数（日本人移動者）（女）&quot; &quot;婚姻件数&quot; &quot;離婚件数&quot; ## [34] &quot;年平均気温&quot; &quot;最高気温（日最高気温の月平均の最高値）&quot; &quot;最低気温（日最低気温の月平均の最低値）&quot; ## [37] &quot;降水日数（年間）&quot; &quot;降水量（年間）&quot; &quot;着工建築物数&quot; ## [40] &quot;着工建築物床面積&quot; &quot;旅館営業施設数（ホテルを含む）&quot; &quot;旅館営業施設客室数（ホテルを含む）&quot; ## [43] &quot;標準価格（平均価格）（住宅地）&quot; &quot;標準価格（平均価格）（商業地）&quot; &quot;幼稚園数&quot; ## [46] &quot;幼稚園教員数&quot; &quot;幼稚園在園者数&quot; &quot;小学校数&quot; ## [49] &quot;小学校教員数&quot; &quot;小学校児童数&quot; &quot;中学校数&quot; ## [52] &quot;中学校教員数&quot; &quot;中学校生徒数&quot; &quot;中学校卒業者数&quot; ## [55] &quot;中学校卒業者のうち進学者数&quot; &quot;高等学校数&quot; &quot;高等学校教員数&quot; ## [58] &quot;高等学校生徒数&quot; &quot;高等学校卒業者数&quot; &quot;高等学校卒業者のうち進学者数&quot; ## [61] &quot;短期大学数&quot; &quot;大学数&quot; &quot;短期大学教員数&quot; ## [64] &quot;大学教員数&quot; &quot;短期大学学生数&quot; &quot;大学学生数&quot; ## [67] &quot;短期大学卒業者数&quot; &quot;短期大学卒業者のうち進学者数&quot; &quot;大学卒業者数&quot; ## [70] &quot;大学卒業者のうち進学者数&quot; &quot;専修学校数&quot; &quot;各種学校数&quot; ## [73] &quot;専修学校生徒数&quot; &quot;各種学校生徒数&quot; &quot;新規求職申込件数（一般）&quot; ## [76] &quot;月間有効求職者数（一般）&quot; &quot;月間有効求人数（一般）&quot; &quot;充足数（一般）&quot; ## [79] &quot;就職件数（一般）&quot; &quot;一般旅券発行件数&quot; &quot;延べ宿泊者数&quot; ## [82] &quot;外国人延べ宿泊者数&quot; &quot;着工新設住宅戸数&quot; &quot;着工新設持家数&quot; ## [85] &quot;着工新設貸家数&quot; &quot;着工新設分譲住宅数&quot; &quot;着工新設住宅床面積&quot; ## [88] &quot;着工新設持家床面積&quot; &quot;着工新設分譲住宅床面積&quot; &quot;着工新設貸家床面積&quot; ## [91] &quot;ごみ総排出量（総量）&quot; &quot;1人1日当たりの排出量&quot; &quot;ごみのリサイクル率&quot; ## [94] &quot;一般病院数&quot; &quot;一般診療所数&quot; &quot;歯科診療所数&quot; ## [97] &quot;保育所等数&quot; &quot;保育所等定員数&quot; &quot;保育所等利用待機児童数&quot; ## [100] &quot;保育所等在所児数&quot; &quot;保育所等保育士数&quot; &quot;消費支出（二人以上の世帯）&quot; ## [103] &quot;食料費（二人以上の世帯）&quot; &quot;住居費（二人以上の世帯）&quot; &quot;光熱・水道費（二人以上の世帯）&quot; ## [106] &quot;家具・家事用品費（二人以上の世帯）&quot; &quot;被服及び履物費（二人以上の世帯）&quot; &quot;保健医療費（二人以上の世帯）&quot; ## [109] &quot;交通・通信費（二人以上の世帯）&quot; &quot;教育費（二人以上の世帯）&quot; &quot;教養娯楽費（二人以上の世帯）&quot; ## [112] &quot;その他の消費支出（二人以上の世帯）&quot; data_kanto &lt;- data_ssdse |&gt; filter(都道府県 %in% c(&quot;東京都&quot;,&quot;神奈川県&quot;,&quot;千葉県&quot;,&quot;埼玉県&quot;,&quot;茨城県&quot;,&quot;栃木県&quot;,&quot;群馬県&quot;)) plot_f_rate &lt;- ggplot(data=data_kanto,aes(x=年度, y=大学卒業者数, col=都道府県)) + geom_line() + geom_point() + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) plot_f_rate plot_f_rate &lt;- ggplot(data=data_kanto,aes(x=年度, y=大学卒業者数, col=都道府県)) + geom_line() + geom_point() + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) + labs(x=&quot;Fiscal Year&quot;, y=&quot;Number Of University Graduates&quot;, col=&quot;Pref.&quot;) + scale_color_discrete(breaks = c(&quot;千葉県&quot;,&quot;埼玉県&quot;,&quot;東京都&quot;,&quot;栃木県&quot;,&quot;神奈川県&quot;,&quot;群馬県&quot;,&quot;茨城県&quot;), labels = c(&quot;Chiba&quot;,&quot;Saitama&quot;,&quot;Tokyo&quot;,&quot;Tochigi&quot;,&quot;Kanagawa&quot;,&quot;Gumma&quot;,&quot;Ibaragi&quot;)) + theme(text = element_text(size=15)) plot_f_rate ggsave(&quot;fig/fertility_rate_by_pref_2010_2021.png&quot;,plot_f_rate, device=&quot;png&quot;) warnings() 17.1.2 フィードバック 具体例と大きく変わりないですが、基本的な描画はできていると思います。 17.2 Yugo Kaneko 17.2.1 オリジナルコード #パッケージの読み込み library(tidyverse) library(tidyr) #データの読み込みと変数名の確認 data_ssdse&lt;- read_csv(&quot;data/SSDSE-B-2024.csv&quot;,locale=locale(encoding=&quot;CP932&quot;) ,skip=1) names(data_ssdse) ## [1] &quot;年度&quot; &quot;地域コード&quot; &quot;都道府県&quot; ## [4] &quot;総人口&quot; &quot;総人口（男）&quot; &quot;総人口（女）&quot; ## [7] &quot;日本人人口&quot; &quot;日本人人口（男）&quot; &quot;日本人人口（女）&quot; ## [10] &quot;15歳未満人口&quot; &quot;15歳未満人口（男）&quot; &quot;15歳未満人口（女）&quot; ## [13] &quot;15〜64歳人口&quot; &quot;15〜64歳人口（男）&quot; &quot;15〜64歳人口（女）&quot; ## [16] &quot;65歳以上人口&quot; &quot;65歳以上人口（男）&quot; &quot;65歳以上人口（女）&quot; ## [19] &quot;出生数&quot; &quot;出生数（男）&quot; &quot;出生数（女）&quot; ## [22] &quot;合計特殊出生率&quot; &quot;死亡数&quot; &quot;死亡数（男）&quot; ## [25] &quot;死亡数（女）&quot; &quot;転入者数（日本人移動者）&quot; &quot;転入者数（日本人移動者）（男）&quot; ## [28] &quot;転入者数（日本人移動者）（女）&quot; &quot;転出者数（日本人移動者）&quot; &quot;転出者数（日本人移動者）（男）&quot; ## [31] &quot;転出者数（日本人移動者）（女）&quot; &quot;婚姻件数&quot; &quot;離婚件数&quot; ## [34] &quot;年平均気温&quot; &quot;最高気温（日最高気温の月平均の最高値）&quot; &quot;最低気温（日最低気温の月平均の最低値）&quot; ## [37] &quot;降水日数（年間）&quot; &quot;降水量（年間）&quot; &quot;着工建築物数&quot; ## [40] &quot;着工建築物床面積&quot; &quot;旅館営業施設数（ホテルを含む）&quot; &quot;旅館営業施設客室数（ホテルを含む）&quot; ## [43] &quot;標準価格（平均価格）（住宅地）&quot; &quot;標準価格（平均価格）（商業地）&quot; &quot;幼稚園数&quot; ## [46] &quot;幼稚園教員数&quot; &quot;幼稚園在園者数&quot; &quot;小学校数&quot; ## [49] &quot;小学校教員数&quot; &quot;小学校児童数&quot; &quot;中学校数&quot; ## [52] &quot;中学校教員数&quot; &quot;中学校生徒数&quot; &quot;中学校卒業者数&quot; ## [55] &quot;中学校卒業者のうち進学者数&quot; &quot;高等学校数&quot; &quot;高等学校教員数&quot; ## [58] &quot;高等学校生徒数&quot; &quot;高等学校卒業者数&quot; &quot;高等学校卒業者のうち進学者数&quot; ## [61] &quot;短期大学数&quot; &quot;大学数&quot; &quot;短期大学教員数&quot; ## [64] &quot;大学教員数&quot; &quot;短期大学学生数&quot; &quot;大学学生数&quot; ## [67] &quot;短期大学卒業者数&quot; &quot;短期大学卒業者のうち進学者数&quot; &quot;大学卒業者数&quot; ## [70] &quot;大学卒業者のうち進学者数&quot; &quot;専修学校数&quot; &quot;各種学校数&quot; ## [73] &quot;専修学校生徒数&quot; &quot;各種学校生徒数&quot; &quot;新規求職申込件数（一般）&quot; ## [76] &quot;月間有効求職者数（一般）&quot; &quot;月間有効求人数（一般）&quot; &quot;充足数（一般）&quot; ## [79] &quot;就職件数（一般）&quot; &quot;一般旅券発行件数&quot; &quot;延べ宿泊者数&quot; ## [82] &quot;外国人延べ宿泊者数&quot; &quot;着工新設住宅戸数&quot; &quot;着工新設持家数&quot; ## [85] &quot;着工新設貸家数&quot; &quot;着工新設分譲住宅数&quot; &quot;着工新設住宅床面積&quot; ## [88] &quot;着工新設持家床面積&quot; &quot;着工新設分譲住宅床面積&quot; &quot;着工新設貸家床面積&quot; ## [91] &quot;ごみ総排出量（総量）&quot; &quot;1人1日当たりの排出量&quot; &quot;ごみのリサイクル率&quot; ## [94] &quot;一般病院数&quot; &quot;一般診療所数&quot; &quot;歯科診療所数&quot; ## [97] &quot;保育所等数&quot; &quot;保育所等定員数&quot; &quot;保育所等利用待機児童数&quot; ## [100] &quot;保育所等在所児数&quot; &quot;保育所等保育士数&quot; &quot;消費支出（二人以上の世帯）&quot; ## [103] &quot;食料費（二人以上の世帯）&quot; &quot;住居費（二人以上の世帯）&quot; &quot;光熱・水道費（二人以上の世帯）&quot; ## [106] &quot;家具・家事用品費（二人以上の世帯）&quot; &quot;被服及び履物費（二人以上の世帯）&quot; &quot;保健医療費（二人以上の世帯）&quot; ## [109] &quot;交通・通信費（二人以上の世帯）&quot; &quot;教育費（二人以上の世帯）&quot; &quot;教養娯楽費（二人以上の世帯）&quot; ## [112] &quot;その他の消費支出（二人以上の世帯）&quot; #西日本主要府県に限定した、データの表示 data_nishinihonsyuyoufukenn&lt;- data_ssdse|&gt; filter(都道府県 %in% c(&quot;大阪府&quot;,&quot;京都府&quot;,&quot;兵庫県&quot;,&quot;福岡県&quot;,&quot;愛知県&quot;)) ## long型に変換。 data_nishinihonnsyuyoufukenn_long &lt;- data_nishinihonsyuyoufukenn |&gt; pivot_longer(cols=c(&quot;中学校数&quot;))  #キャンバスの用意 plot_data_nishinihonnsyuyoufukenn&lt;-ggplot() print(plot_data_nishinihonnsyuyoufukenn) #グラフの描画 plot_f_rate&lt;- ggplot(data=data_nishinihonnsyuyoufukenn_long, mapping=aes(x=年度, y=大学数,col=都道府県))+ geom_line()+ geom_point()+ labs(x=&quot;Fiscal Year&quot;, y=&quot;THE NUMBER OF UNIVERSITIES&quot;, col=&quot;Pref.&quot; ,title=&quot;西日本主要府県の大学数の推移&quot;,subtitle=&quot;データ元：https://www.nstac.go.jp/use/literacy/ssdse/#SSDSE-Bhttps://www.nstac.go.jp/use/literacy/ssdse/#SSDSE-B&quot;) + scale_color_discrete(breaks = c(&quot;大阪府&quot;,&quot;京都府&quot;,&quot;兵庫県&quot;,&quot;福岡県&quot;,&quot;愛知県&quot;), labels = c(&quot;osaka&quot;,&quot;kyoto&quot;,&quot;hyogo&quot;,&quot;fukuoka&quot;,&quot;aichi&quot;)) + theme(text = element_text(size=15)) + theme_gray(base_family = &quot;HiraKakuPro-W3&quot;) # Mac用に追加 plot_f_rate #データの保存 fs::dir_create(&quot;fig&quot;) ggsave(&quot;fig/fertility_rate_by_pref_2010_2021.png&quot;,plot_f_rate, device=&quot;png&quot;) 17.2.2 フィードバック 基本的な描画はできています。 タイトルも英語にしたほうがいいです。 データ元はsubtitleよりもcaptionにしたほうが見やすいかもしれません。 17.3 Yui Kunimatsu 17.3.1 オリジナルコード library(tidyverse) fs::dir_create(&quot;data&quot;) download.file(&quot;download.file/Users/yuinya/abezemi/SSDSE.xlsx&quot;, destfile=&quot;SSDSE.xlsx&quot;) data_634 &lt;- readxl::read_excel(&quot;SSDSE.xlsx/SSDSE.xlsx&quot;) # long型(tidy data)に変換 data_634_long &lt;- data_634 |&gt; # long型に変換。1年〜４年の列(cols)を学生数という列にvalues_toでまとめる。各行に何年生かnames_toで記録する。 pivot_longer(cols=c(2010:2021),names_to =&quot;年度&quot;,values_to = &quot;合計特殊出生率&quot;) plot_634 &lt;- ggplot() print(plot_634) plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=年度, y=合計特殊出生率),stat=&quot;identity&quot;) # &lt;- 追加！ plot_634 &lt;- ggplot() + geom_bar(data=data_634_long, mapping=aes(x=年度, y=合計特殊出生率),stat=&quot;identity&quot;) + theme_grey(base_family=&quot;HiraKakuPro-W3&quot;) # &lt;- 追加！ print(plot_634) 17.3.2 フィードバック 基本的な描画はできていますが、データの読み込みはこれでうまくいきましたか？ 整然データへの変換は必要ないように思います（SSDSEはすでに整然データになっています）。 時系列の変化を描く場合は、折れ線グラフを使ったほうがいいかもしれません。 17.4 Kotaro Mezaki library(tidyverse) library(readxl) getwd() ## [1] &quot;/Users/keita/Library/CloudStorage/Dropbox/Teaching/regression_tutorial&quot; data_ssdse &lt;- read_csv(&quot;data/SSDSE-B-2024.csv&quot;, locale=locale(encoding=&quot;CP932&quot;), skip=1) # 変数名を確認 names(data_ssdse) ## [1] &quot;年度&quot; &quot;地域コード&quot; &quot;都道府県&quot; ## [4] &quot;総人口&quot; &quot;総人口（男）&quot; &quot;総人口（女）&quot; ## [7] &quot;日本人人口&quot; &quot;日本人人口（男）&quot; &quot;日本人人口（女）&quot; ## [10] &quot;15歳未満人口&quot; &quot;15歳未満人口（男）&quot; &quot;15歳未満人口（女）&quot; ## [13] &quot;15〜64歳人口&quot; &quot;15〜64歳人口（男）&quot; &quot;15〜64歳人口（女）&quot; ## [16] &quot;65歳以上人口&quot; &quot;65歳以上人口（男）&quot; &quot;65歳以上人口（女）&quot; ## [19] &quot;出生数&quot; &quot;出生数（男）&quot; &quot;出生数（女）&quot; ## [22] &quot;合計特殊出生率&quot; &quot;死亡数&quot; &quot;死亡数（男）&quot; ## [25] &quot;死亡数（女）&quot; &quot;転入者数（日本人移動者）&quot; &quot;転入者数（日本人移動者）（男）&quot; ## [28] &quot;転入者数（日本人移動者）（女）&quot; &quot;転出者数（日本人移動者）&quot; &quot;転出者数（日本人移動者）（男）&quot; ## [31] &quot;転出者数（日本人移動者）（女）&quot; &quot;婚姻件数&quot; &quot;離婚件数&quot; ## [34] &quot;年平均気温&quot; &quot;最高気温（日最高気温の月平均の最高値）&quot; &quot;最低気温（日最低気温の月平均の最低値）&quot; ## [37] &quot;降水日数（年間）&quot; &quot;降水量（年間）&quot; &quot;着工建築物数&quot; ## [40] &quot;着工建築物床面積&quot; &quot;旅館営業施設数（ホテルを含む）&quot; &quot;旅館営業施設客室数（ホテルを含む）&quot; ## [43] &quot;標準価格（平均価格）（住宅地）&quot; &quot;標準価格（平均価格）（商業地）&quot; &quot;幼稚園数&quot; ## [46] &quot;幼稚園教員数&quot; &quot;幼稚園在園者数&quot; &quot;小学校数&quot; ## [49] &quot;小学校教員数&quot; &quot;小学校児童数&quot; &quot;中学校数&quot; ## [52] &quot;中学校教員数&quot; &quot;中学校生徒数&quot; &quot;中学校卒業者数&quot; ## [55] &quot;中学校卒業者のうち進学者数&quot; &quot;高等学校数&quot; &quot;高等学校教員数&quot; ## [58] &quot;高等学校生徒数&quot; &quot;高等学校卒業者数&quot; &quot;高等学校卒業者のうち進学者数&quot; ## [61] &quot;短期大学数&quot; &quot;大学数&quot; &quot;短期大学教員数&quot; ## [64] &quot;大学教員数&quot; &quot;短期大学学生数&quot; &quot;大学学生数&quot; ## [67] &quot;短期大学卒業者数&quot; &quot;短期大学卒業者のうち進学者数&quot; &quot;大学卒業者数&quot; ## [70] &quot;大学卒業者のうち進学者数&quot; &quot;専修学校数&quot; &quot;各種学校数&quot; ## [73] &quot;専修学校生徒数&quot; &quot;各種学校生徒数&quot; &quot;新規求職申込件数（一般）&quot; ## [76] &quot;月間有効求職者数（一般）&quot; &quot;月間有効求人数（一般）&quot; &quot;充足数（一般）&quot; ## [79] &quot;就職件数（一般）&quot; &quot;一般旅券発行件数&quot; &quot;延べ宿泊者数&quot; ## [82] &quot;外国人延べ宿泊者数&quot; &quot;着工新設住宅戸数&quot; &quot;着工新設持家数&quot; ## [85] &quot;着工新設貸家数&quot; &quot;着工新設分譲住宅数&quot; &quot;着工新設住宅床面積&quot; ## [88] &quot;着工新設持家床面積&quot; &quot;着工新設分譲住宅床面積&quot; &quot;着工新設貸家床面積&quot; ## [91] &quot;ごみ総排出量（総量）&quot; &quot;1人1日当たりの排出量&quot; &quot;ごみのリサイクル率&quot; ## [94] &quot;一般病院数&quot; &quot;一般診療所数&quot; &quot;歯科診療所数&quot; ## [97] &quot;保育所等数&quot; &quot;保育所等定員数&quot; &quot;保育所等利用待機児童数&quot; ## [100] &quot;保育所等在所児数&quot; &quot;保育所等保育士数&quot; &quot;消費支出（二人以上の世帯）&quot; ## [103] &quot;食料費（二人以上の世帯）&quot; &quot;住居費（二人以上の世帯）&quot; &quot;光熱・水道費（二人以上の世帯）&quot; ## [106] &quot;家具・家事用品費（二人以上の世帯）&quot; &quot;被服及び履物費（二人以上の世帯）&quot; &quot;保健医療費（二人以上の世帯）&quot; ## [109] &quot;交通・通信費（二人以上の世帯）&quot; &quot;教育費（二人以上の世帯）&quot; &quot;教養娯楽費（二人以上の世帯）&quot; ## [112] &quot;その他の消費支出（二人以上の世帯）&quot; data_kanto_yamaguti&lt;- data_ssdse |&gt; filter(都道府県 %in% c(&quot;東京都&quot;,&quot;神奈川県&quot;,&quot;千葉県&quot;,&quot;埼玉県&quot;,&quot;茨城県&quot;,&quot;栃木県&quot;,&quot;群馬県&quot;,&quot;山口県&quot;)) # %in% は 「都道府県というカテゴリ変数が、c()の中のいずれかに該当すれば真、という命題を表す。 plot_f_rate &lt;- ggplot(data=data_kanto_yamaguti,aes(x=年度, y=ごみのリサイクル率, col=都道府県)) + geom_line() + geom_point() + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) plot_f_rate plot_f_rate &lt;- ggplot(data=data_kanto_yamaguti,aes(x=年度, y=ごみのリサイクル率, col=都道府県)) + geom_line() + geom_point() + theme_bw(base_family = &quot;HiraKakuPro-W3&quot;) + labs(x=&quot;Year&quot;, y=&quot;Garbage recycling rate&quot;, col=&quot;Pref.&quot;) + scale_color_discrete(breaks = c(&quot;千葉県&quot;,&quot;埼玉県&quot;,&quot;東京都&quot;,&quot;栃木県&quot;,&quot;神奈川県&quot;,&quot;群馬県&quot;,&quot;茨城県&quot;,&quot;山口県&quot;), labels = c(&quot;Chiba&quot;,&quot;Saitama&quot;,&quot;Tokyo&quot;,&quot;Tochigi&quot;,&quot;Kanagawa&quot;,&quot;Gumma&quot;,&quot;Ibaragi&quot;,&quot;yamaguti&quot;)) + theme(text = element_text(size=15)) plot_f_rate ggsave(file=&quot;fig/Garbage recycling rate_pref_2010_2021.png&quot;,plot_f_rate,device = &quot;png&quot;) 17.4.1 フィードバック 基本的な描画はできています。 なぜ山口が含まれているかはぜひプレゼンで説明してください。 17.5 Rei Shimizu library(tidyverse) library(readxl) data_pop &lt;- read_csv(&quot;data/SSDSE-B-2024.csv&quot;,locale=locale(encoding=&quot;CP932&quot;), skip=1) data_pop_fil&lt;-data_pop|&gt; filter( 都道府県 %in% c(&quot;千葉県&quot;,&quot;埼玉県&quot;), 年度%in%c(&quot;2016&quot;,&quot;2017&quot;,&quot;2018&quot;,&quot;2019&quot;,&quot;2020&quot;,&quot;2021&quot;)) plot_pop_fil&lt;-ggplot(data=data_pop_fil,mapping=aes(x=年度,y=総人口,col=都道府県))+ geom_line()+ geom_point()+ labs(x=&quot;Fiscal Year&quot;, y=&quot;Population&quot;, col=&quot;Pref.&quot;) + scale_color_discrete(breaks = c(&quot;千葉県&quot;,&quot;埼玉県&quot;), labels = c(&quot;Chiba&quot;,&quot;Saitama&quot;))+ theme(text = element_text(size=15)) print(plot_pop_fil) data_pop_fil2&lt;-data_pop|&gt; filter( 都道府県 %in% c(&quot;長野県&quot;,&quot;福島県&quot;), 年度%in%c(&quot;2016&quot;,&quot;2017&quot;,&quot;2018&quot;,&quot;2019&quot;,&quot;2020&quot;,&quot;2021&quot;)) plot_pop_fil2&lt;-ggplot(data=data_pop_fil2,mapping=aes(x=年度,y=総人口,col=都道府県))+ geom_line()+ geom_point()+ labs(x=&quot;Fiscal Year&quot;, y=&quot;Population&quot;, col=&quot;Pref.&quot;) + scale_color_discrete(breaks = c(&quot;長野県&quot;,&quot;福島県&quot;), labels = c(&quot;Nagano&quot;,&quot;Fukusima&quot;))+ theme(text = element_text(size=15)) print(plot_pop_fil2) 17.5.1 フィードバック 基本的な描画はできています。 人口のように数値が大きい場合は、一定の数で割って、単位を変更すると見やすいです。 plot_pop_fil2&lt;-ggplot(data=data_pop_fil2,mapping=aes(x=年度,y=総人口/1000,col=都道府県))+ # &lt;- ここを変更 geom_line()+ geom_point()+ labs(x=&quot;Fiscal Year&quot;, y=&quot;Population (Thousands)&quot;, col=&quot;Pref.&quot;) + # &lt;- ここを変更 scale_color_discrete(breaks = c(&quot;長野県&quot;,&quot;福島県&quot;), labels = c(&quot;Nagano&quot;,&quot;Fukusima&quot;))+ theme(text = element_text(size=15)) print(plot_pop_fil2) 17.6 Yuta Shimizu library(tidyverse) library(readxl) data635 &lt;- readxl::read_excel(&quot;data/zemiyou.xlsx&quot;) data635 plot635 &lt;- ggplot()+ geom_bar(data=data635,mapping=aes(x=reorder(都道府県,カップ麺),y=カップ麺),stat=&quot;identity&quot;)+ labs(fill=&quot;&quot;,x=&quot;&quot;,y=&quot;&quot;, title=&quot;県別年間カップ麺消費量&quot;, subtitle=&quot;2024年4月24日公開&quot;, caption = &quot;データ元SSDSE-家計消費&quot; ) plot635 &lt;- ggplot()+ geom_bar(data=data635,mapping=aes(x=カップ麺,y=都道府県),stat=&quot;identity&quot;)+ labs(fill=&quot;&quot;,x=&quot;&quot;,y=&quot;&quot;, title=&quot;県別年間カップ麺消費量&quot;, subtitle=&quot;2024年4月24日公開&quot;, caption = &quot;データ元SSDSE-家計消費&quot; ) + theme_grey(base_family = &quot;HiraKakuPro-W3&quot;) # Mac用に追加 plot635 17.6.1 フィードバック 基本的な描画はできています。 英語で発表するので、英語に直しましょう。 コメントにあったカテゴリの順番を変える方法は、以下の通りです。 アイデアとしては、データにおけるカテゴリの順番を変えるという発想です。 data635 &lt;- data635 |&gt; # mutate()ですでにある都道府県の列を更新する # カテゴリの順番は、fct_reorderで変更することができる。 # これはtidyverseに入っているforcatというパッケージに入っている関数。 mutate(都道府県 = fct_reorder(都道府県, カップ麺)) plot635 &lt;- ggplot()+ geom_bar(data=data635,mapping=aes(x=カップ麺,y=都道府県),stat=&quot;identity&quot;)+ labs(fill=&quot;&quot;,x=&quot;&quot;,y=&quot;&quot;, title=&quot;県別年間カップ麺消費量&quot;, subtitle=&quot;2024年4月24日公開&quot;, caption = &quot;データ元SSDSE-家計消費&quot; ) + theme_grey(base_family = &quot;HiraKakuPro-W3&quot;) + # Mac用に追加 theme(axis.text.y = element_text(size=7)) # themeの中で、axis.text.yという項目のtextという要素で、文字サイズを変えることが可能。 plot635 17.7 Hyuga Yamanouchi library(tidyverse) data_ssdse &lt;- read_csv(&quot;data/SSDSE-B-2024.csv&quot;, locale=locale(encoding=&quot;CP932&quot;), skip=1) data_ssdse ## # A tibble: 600 × 112 ## 年度 地域コード 都道府県 総人口 `総人口（男）` `総人口（女）` 日本人人口 `日本人人口（男）` `日本人人口（女）` `15歳未満人口` `15歳未満人口（男）` ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021 R01000 北海道 5183000 2446000 2737000 5147000 2429000 2717000 544000 278000 ## 2 2020 R01000 北海道 5224614 2465088 2759526 5151366 2429697 2721669 555804 284510 ## 3 2019 R01000 北海道 5259000 2480000 2780000 5223000 2464000 2759000 565000 289000 ## 4 2018 R01000 北海道 5293000 2495000 2798000 5262000 2482000 2780000 577000 295000 ## 5 2017 R01000 北海道 5325000 2510000 2815000 5298000 2499000 2799000 588000 301000 ## 6 2016 R01000 北海道 5355000 2523000 2831000 5330000 2514000 2817000 600000 306000 ## 7 2015 R01000 北海道 5381733 2537089 2844644 5348768 2522980 2825788 608296 310387 ## 8 2014 R01000 北海道 5410000 2551000 2859000 5390000 2543000 2847000 621000 316000 ## 9 2013 R01000 北海道 5438000 2565000 2873000 5419000 2558000 2861000 630000 321000 ## 10 2012 R01000 北海道 5465000 2580000 2886000 5446000 2572000 2874000 640000 326000 ## # ℹ 590 more rows ## # ℹ 101 more variables: `15歳未満人口（女）` &lt;dbl&gt;, `15〜64歳人口` &lt;dbl&gt;, `15〜64歳人口（男）` &lt;dbl&gt;, `15〜64歳人口（女）` &lt;dbl&gt;, `65歳以上人口` &lt;dbl&gt;, ## # `65歳以上人口（男）` &lt;dbl&gt;, `65歳以上人口（女）` &lt;dbl&gt;, 出生数 &lt;dbl&gt;, `出生数（男）` &lt;dbl&gt;, `出生数（女）` &lt;dbl&gt;, 合計特殊出生率 &lt;dbl&gt;, 死亡数 &lt;dbl&gt;, ## # `死亡数（男）` &lt;dbl&gt;, `死亡数（女）` &lt;dbl&gt;, `転入者数（日本人移動者）` &lt;dbl&gt;, `転入者数（日本人移動者）（男）` &lt;dbl&gt;, ## # `転入者数（日本人移動者）（女）` &lt;dbl&gt;, `転出者数（日本人移動者）` &lt;dbl&gt;, `転出者数（日本人移動者）（男）` &lt;dbl&gt;, `転出者数（日本人移動者）（女）` &lt;dbl&gt;, ## # 婚姻件数 &lt;dbl&gt;, 離婚件数 &lt;dbl&gt;, 年平均気温 &lt;dbl&gt;, `最高気温（日最高気温の月平均の最高値）` &lt;dbl&gt;, `最低気温（日最低気温の月平均の最低値）` &lt;dbl&gt;, ## # `降水日数（年間）` &lt;dbl&gt;, `降水量（年間）` &lt;chr&gt;, 着工建築物数 &lt;dbl&gt;, 着工建築物床面積 &lt;dbl&gt;, `旅館営業施設数（ホテルを含む）` &lt;dbl&gt;, … data_ssdse_kanto&lt;-data_ssdse|&gt; filter(都道府県%in% c(&quot;東京都&quot;,&quot;神奈川県&quot;,&quot;埼玉県&quot;,&quot;千葉県&quot;,&quot;茨城県&quot;,&quot;栃木県&quot;,&quot;群馬県&quot;)) data_ssdse_kanto ## # A tibble: 84 × 112 ## 年度 地域コード 都道府県 総人口 `総人口（男）` `総人口（女）` 日本人人口 `日本人人口（男）` `日本人人口（女）` `15歳未満人口` `15歳未満人口（男）` ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2021 R08000 茨城県 2852000 1423000 1428000 2785000 1389000 1396000 328000 168000 ## 2 2020 R08000 茨城県 2867009 1430976 1436033 2763432 1378266 1385166 333741 171136 ## 3 2019 R08000 茨城県 2879000 1437000 1442000 2818000 1406000 1412000 342000 175000 ## 4 2018 R08000 茨城県 2892000 1443000 1449000 2836000 1415000 1421000 349000 179000 ## 5 2017 R08000 茨城県 2902000 1448000 1454000 2852000 1422000 1429000 355000 182000 ## 6 2016 R08000 茨城県 2910000 1451000 1459000 2864000 1428000 1436000 361000 185000 ## 7 2015 R08000 茨城県 2916976 1453594 1463382 2862997 1428192 1434805 364351 186926 ## 8 2014 R08000 茨城県 2927000 1458000 1469000 2887000 1439000 1448000 376000 193000 ## 9 2013 R08000 茨城県 2937000 1464000 1474000 2899000 1446000 1453000 382000 196000 ## 10 2012 R08000 茨城県 2947000 1469000 1478000 2910000 1452000 1459000 388000 199000 ## # ℹ 74 more rows ## # ℹ 101 more variables: `15歳未満人口（女）` &lt;dbl&gt;, `15〜64歳人口` &lt;dbl&gt;, `15〜64歳人口（男）` &lt;dbl&gt;, `15〜64歳人口（女）` &lt;dbl&gt;, `65歳以上人口` &lt;dbl&gt;, ## # `65歳以上人口（男）` &lt;dbl&gt;, `65歳以上人口（女）` &lt;dbl&gt;, 出生数 &lt;dbl&gt;, `出生数（男）` &lt;dbl&gt;, `出生数（女）` &lt;dbl&gt;, 合計特殊出生率 &lt;dbl&gt;, 死亡数 &lt;dbl&gt;, ## # `死亡数（男）` &lt;dbl&gt;, `死亡数（女）` &lt;dbl&gt;, `転入者数（日本人移動者）` &lt;dbl&gt;, `転入者数（日本人移動者）（男）` &lt;dbl&gt;, ## # `転入者数（日本人移動者）（女）` &lt;dbl&gt;, `転出者数（日本人移動者）` &lt;dbl&gt;, `転出者数（日本人移動者）（男）` &lt;dbl&gt;, `転出者数（日本人移動者）（女）` &lt;dbl&gt;, ## # 婚姻件数 &lt;dbl&gt;, 離婚件数 &lt;dbl&gt;, 年平均気温 &lt;dbl&gt;, `最高気温（日最高気温の月平均の最高値）` &lt;dbl&gt;, `最低気温（日最低気温の月平均の最低値）` &lt;dbl&gt;, ## # `降水日数（年間）` &lt;dbl&gt;, `降水量（年間）` &lt;chr&gt;, 着工建築物数 &lt;dbl&gt;, 着工建築物床面積 &lt;dbl&gt;, `旅館営業施設数（ホテルを含む）` &lt;dbl&gt;, … plot_ssdse_applicants&lt;-ggplot(data=data_ssdse_kanto,aes(x=年度,y=`月間有効求職者数（一般）`,col=都道府県))+ geom_line()+ geom_point()+ theme_bw(base_family = &quot;HirakakuPro-W3&quot;)+ labs(x=&quot;Fiscal Year&quot;,y=&quot;Total Job Applicants&quot;,col=&quot;Pref.&quot;)+ scale_color_discrete(breaks=c(&quot;東京都&quot;,&quot;神奈川県&quot;,&quot;埼玉県&quot;,&quot;千葉県&quot;,&quot;茨城県&quot;,&quot;栃木県&quot;,&quot;群馬県&quot;), labels=c(&quot;Tokyo&quot;,&quot;Kanagawa&quot;,&quot;Saitama&quot;,&quot;Chiba&quot;,&quot;Ibaraki&quot;,&quot;Tochigi&quot;,&quot;Gunma&quot;))+ theme(text=element_text(size=10)) plot_ssdse_applicants ggsave(file=&quot;fig/Total_Job_Applicants_by_pref_2010_2021.png&quot;,plot_ssdse_applicants,device=&quot;png&quot;) #こっちを採用 ggsave(file=&quot;fig/Total_Job_Applicants_2_by_pref_2010_2021.png&quot;,plot_ssdse_applicants,device=&quot;png&quot;) 17.7.1 フィードバック 基本的な描画はできています。 プレゼン用としては、少し字を大きくするといいかもしれません。 17.8 Jinto Eguro library(tidyverse) library(readxl) data_F&lt;-readxl::read_excel(&quot;data/SSDSE-A-2023.xlsx&quot;) data_F plotF&lt;-ggplot() print(plotF) plotF&lt;-ggplot()+ geom_bar(data=data_F,mapping = aes(x=市区町村,y=外国人人口),stat = &quot;identity&quot;) print(plotF) 17.8.1 フィードバック 基本的な描画はできています。 データを読み込むとき、エクセルファイルだと最初に2行不要な行があるので、skip=2という引数をread_excel()の中に追加して、最初の2行を飛ばすとよいです。 描画はできていますが、市区町村だと数が多すぎるので、下のテクニックの補足のように一部を取り出して描画するとよいです。 17.9 描画テクニックの補足 17.9.1 グラフのカテゴリの順番を変更するには？ 例として、SSDSE-Cのデータを使います。 data_ssdse_c &lt;- read_csv(&quot;data/SSDSE-C-2024.csv&quot;,locale=locale(encoding = &quot;cp932&quot;),skip=1) 例として、各都道府県の魚介類消費量を棒グラフにしてみる。 横向きのグラフにするため、x軸に変数（02 魚介類）を、y軸に都道府県を取る。 ちなみに変数名にカッコやスペースが入っていると、うまく認識されないためにエラーが出ることがある。この場合には、02と魚介類の間にスペースが入っているので、このままmappingに入力すると、エラーが出る。そのため`で囲むことで、スペースやカッコをふくめたひとまとまりが変数名であることを明示できる。 ggplot(data=data_ssdse_c, aes(y=都道府県, x=`02 魚介類`)) + geom_bar(stat=&quot;identity&quot;) + theme_bw(base_family=&quot;HiraKakuPro-W3&quot;) 各都道府県のデータを見せることができたが、 1. 順番がバラバラでわかりにくい。ランキング形式で表示できると良さそう。 2. 左軸に都道府県すべてが表示されていて、多いので見にくい。 という問題がある。 17.9.1.1 順番を変える方法 ggplotはカテゴリ（例えば都道府県）を表示する際に適当に並び替えてしまうため、思ったとおりの順番でカテゴリーを表示してくれないケースがある。 カテゴリの順番を変えるには、データの要素の順番を変える必要がある。 tidyverseパッケージには、forcatsというパッケージが含まれており、そこにfct_reorder()という関数がある。fct_reorder()の１つ目の引数には、順番を変更する変数を、２つ目には順番に使うものを指定する。 この場合は、１つ目に都道府県、２つ目に02 魚介類を指定して、都道府県を魚介類消費量の順番に要素として並び替えている。 data_ssdse_c &lt;- data_ssdse_c |&gt; mutate(都道府県 = fct_reorder(都道府県, `02 魚介類`)) このデータを用いると、順番が変更された形で図を描くことができる。 ggplot(data=data_ssdse_c, aes(y=都道府県, x=`02 魚介類`)) + geom_bar(stat=&quot;identity&quot;) + theme_bw(base_family=&quot;HiraKakuPro-W3&quot;) 順番を逆にしたい場合はdesc()関数を使う data_ssdse_c_2 &lt;- data_ssdse_c |&gt; mutate(都道府県 = fct_reorder(都道府県, desc(`02 魚介類`))) ggplot(data=data_ssdse_c_2, aes(y=都道府県, x=`02 魚介類`)) + geom_bar(stat=&quot;identity&quot;) + theme_bw(base_family=&quot;HiraKakuPro-W3&quot;) 17.9.2 カテゴリが多すぎるので減らす方法 データが多すぎる場合、例えばトップ１０のみを見せるというのも手である。 以下のコードでは、データを魚介類に基づいて降順（大きい方から小さい方）に並び替えて、１行目から10行目を抜き出している。 data_ssdse_c_3 &lt;- data_ssdse_c |&gt; arrange(desc(`02 魚介類`)) |&gt; # 順番を降順に変更 slice(1:10)           # 1行目から１０行目を「スライス」する このデータを使って描くと、消費量トップ10の都道府県のデータを描くことができる。 ggplot(data=data_ssdse_c_3, aes(y=都道府県, x=`02 魚介類`)) + geom_bar(stat=&quot;identity&quot;) + theme_bw(base_family=&quot;HiraKakuPro-W3&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
